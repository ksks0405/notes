---
title: "Notes on Blanchard-Kahn Method in R"
date: "2025-08-05"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    number_sections: FALSE
    code_folding: hide
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

<!-- The chunks in this code are classified as follows: -->

<!-- -   SET: Load package, set default options, define functions and variables, etc. -->

<!-- -   IMP: Import data. -->

<!-- -   PRE: Process data, including creating and editing variables, -->

<!-- -   FLT: Process data that involve FILTERING. -->

<!-- -   EDA: Exploratory Data Analysis -->

<!-- -   REG: Regressions -->

<!-- -   EXP: Export results -->

# Settings

The chapter contains some chunks that conduct document settings.

-   This chunk **removes all the variables** in the environment.

```{r SET housekeeping}
rm(list = ls(all = TRUE))
```

-   This chunk **sets** `knitr` **options**.

```{r SET knit options}
knitr::opts_chunk$set(
  block.title=T, # default: F / normally F
  fig.align = "center",
  results = "hold",
  fig.show = "hold",
  message = F, # when hiding messages
  warning = F  # when hiding errors
)
knitr::opts_hooks$set(label = function(options) {
  options$before = paste0('<div>Chunk: ', options$label, '</div>')
  return(options)
})
```

-   This chunk **loads the required packages** and **my functions**.

```{r SET libraries, warning=F, include=F}
pkgList <- c("tidyverse", "gt","expm", "QZ", "geigen", "MASS") # expm for %^%
easypackages::libraries(pkgList)
rm(pkgList)

my_gt_default <- function(dta_, font_times = F, font_decimals = 4){
  
  if("gt_tbl" %in% c(class(dta_))){
  } else{
    dta_ <- gt(dta_)
  }
  
  if(font_times){
    dta_ <- dta_ %>% 
      tab_options(
        table.font.names = "Times New Roman",
        table.font.size = "12px"
      )
  }
  
  dta_ <-  dta_%>% 
    fmt_number(columns = where(is.double), decimals = font_decimals) %>% 
    fmt_number(columns = where(is.integer), decimals = 0)
  
  my_gt_default <- dta_
}

my_dplyr_indexmatch <- function(tbl, mapping, target_col, new_col_name = "new_group") {
  # mappingとtarget_colが同数のlistであるかチェック
  if (!(is.list(mapping) && is.list(target_col))) {
    stop("mappingとtarget_colはどちらもlistである必要があります。")
  }
  if (length(mapping) != length(target_col)) {
    stop("mappingとtarget_colは同じ長さである必要があります。")
  }
  
  n <- length(mapping)
  
  # new_col_nameをベクトルとして処理
  if (length(new_col_name) == 1 && n > 1) {
    new_col_name <- paste0(new_col_name, "_", seq_len(n))
  }
  
  if (length(new_col_name) != n) {
    stop("new_col_nameの長さは、mappingとtarget_colの長さに一致する必要があります。")
  }
  
  # 各マッチングに対して列を追加
  for (i in seq_len(n)) {
    map_i <- mapping[[i]]
    col_i <- target_col[[i]]
    name_i <- new_col_name[[i]]
    
    tbl <- tbl %>%
      mutate(!!sym(name_i) := map_i[as.character(.data[[col_i]])])
  }
  return(tbl)
}

```

```{r SET matrix function 2, warning=F, include=F}
to_bmatrix_latex <- function(mat, round = NULL, delete01 = TRUE) {
  if (!is.null(round)) {
    mat <- round(mat, round)
  }
  if(is.matrix(mat) && max(dim(mat))>1){
    ### n by n matrix (n>1)
    # 各行を LaTeX 形式に変換
    rows <- apply(mat, 1, function(row) {paste(row, collapse = " & ")})
    # 行を結合して bmatrix 形式に
    latex_body <- paste(rows, collapse = " \\\\ \n")
    # 数式全体を組み立てる（$$ では囲まない）
    latex_code <- paste0("\\begin{bmatrix}\n", latex_body, "\n\\end{bmatrix}")
  } else if(is.matrix(mat) && max(dim(mat)) == 1){
    ### 1 by 1 matrix
    latex_code <- ifelse(((mat[[1,1]] == 1 | mat[[1,1]] == 0) & delete01), "", as.character(mat[[1,1]]))
  } else if (is.numeric(mat)){
    ### scalar
    latex_code <- ifelse((mat == 1 | mat == 0) & delete01, "", as.character(mat))
  } else{
    stop("mat は行列か数値である必要があります")
  }
  return(latex_code)
}

my_print_matrix_latex <- function(mat_list, round = 4, delete01 = F){
  my_lapply_name <- function(lst, fun_lst_and_nam){
    lst_nam <- names(lst)
    return(Map(fun_lst_and_nam, lst, lst_nam))
  }
  codes_mats <- my_lapply_name(mat_list, function(x, y){
    paste0(y, " = ", to_bmatrix_latex(mat = x, round = round, delete01 = delete01))
  })
  cat("$$", str_c(codes_mats, collapse = ",\\quad "), "$$", sep = "")
  
}

# my_print_matrix_latex(list(B = B, A = A, E = E), round = 2)

my_print_AxByCz_latex <- function(x_code, y_code, z_code = "", w_code = "", 
                                  A_mat = 1, B_mat = 1, C_mat = 0, D_mat = 0,
                                  round = 4, delete01 = T){
  Ax_code <- str_c(to_bmatrix_latex(A_mat, round, delete01), x_code)
  By_code <- str_c(to_bmatrix_latex(B_mat, round, delete01), y_code)
  if(max(dim(C_mat))>1){
    Cz_code <- str_c(" + ", to_bmatrix_latex(C_mat, round, delete01), z_code)
  }else if(C_mat != 0){
    Cz_code <- str_c(" + ", round(C_mat[[1, 1]], round))
  } else{
    Cz_code <-  ""
  }
  if(max(dim(D_mat))>1){
    Dw_code <- str_c(" + ", to_bmatrix_latex(D_mat, round, delete01), w_code)
  }else if(D_mat != 0){
    Dw_code <- str_c(" + ", round(D_mat[[1, 1]], round))
  } else{
    Dw_code <-  ""
  }
  cat("$$", Ax_code, " = ", By_code,Cz_code, Dw_code, "$$", sep = "")  
}
```

-   This chunk sets **the default options for visualization**.

```{r SET graph default}
theme_set(theme_minimal(base_size = 14))
theme_update(
  axis.line = element_line(color = "black"),
  axis.ticks = element_line(color = "black"),
  axis.ticks.length = unit(.5, "lines"),
  panel.grid.major = element_line(color = "grey92"),
  panel.grid.minor = element_blank(),
  legend.title = element_text(size = 14),
  legend.text = element_text(color = "black"),
  plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
  plot.subtitle = element_text(size = 14, color = "black"),
  plot.caption = element_text(hjust = 0)
  # plot.caption = element_text(size = 10, margin = margin(t = 15))
)
```

-   This chunk sets **the seed**.

```{r SET seeds}
set.seed(1111)
```

# Part I. Theory of Solution

## 1. Blanchard-Kahn Method

### Step 1. Setup

Let 

- $x_{t}$ be a vector of $n$ **pre-determined variables**, 

- $y_{t}$ be a vector of $m$ **non pre-determined variables**, and 

- $a_{t}$ be a vector of $k$ **exogenous variables**.

The system can be expressed in the following matrix form:

$$
\begin{align}
  \underset{(n+m) \times (n+m)} B \begin{bmatrix} \underset{(n \times 1)} {x_{t+1}} \\ \underset{(m \times 1)} {\mathbb{E}_t[y_{t+1}]} \end{bmatrix} &= 
    \underset{(n+m) \times (n+m)} A \begin{bmatrix} \underset{(n \times 1)} {x_{t}} \\ \underset{(m \times 1)} {y_{t}} \end{bmatrix} +  \underset{(n+m) \times k} E \quad \underset{k \times 1}{a_t} \\[1em]
  \Leftrightarrow \begin{bmatrix} x_{t+1} \\ \mathbb{E}_t[y_{t+1}] \end{bmatrix} &= 
    \underset{(n+m) \times (n+m)} F \begin{bmatrix} x_t \\ y_t \end{bmatrix} + G a_t, \tag{10.26}
\end{align}
$$

where

$$
\begin{equation} F = B^{-1}A, \quad G = B^{-1}E. \end{equation}
$$

### Step 2. Jordan Decomposition

Using Jordan decomposition, $F$ can be represented as

$$
\begin{equation} F = H J H^{-1}, \tag{9.70} \end{equation}
$$

where

$$
\begin{equation}
  H = \begin{bmatrix} v_1 & v_2 & \cdots & v_{n+m} \end{bmatrix}, \quad
  J = \begin{bmatrix} \lambda_1 & 0 & \cdots & 0 \\ 0 & \lambda_2 & \cdots & 0 \\ \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & \cdots & \lambda_{n+m} \end{bmatrix}.
\end{equation}
$$

Note that $\lambda_i$ is ordered **from the smallest to the largest absolute value**.

### Step 3. Partition into 2 Blocks

Thus, the equation (9.69) can be transformed as

$$
\begin{equation}
  H^{-1} \begin{bmatrix} x_{t+1} \\ \mathbb{E}_t[y_{t+1}] \end{bmatrix} =
    J H^{-1} \begin{bmatrix} x_t \\ y_t \end{bmatrix} + H^{-1} G a_t. \tag{9.71}
\end{equation}
$$

Partition $H^{-1}$ and $J$ into blocks of size $n$ and $m$ and introduce new variables:

$$
\begin{equation*}
  H^{-1} =\begin{bmatrix} \underset{n \times n}{\tilde{H}_{11}} & \underset{n \times m}{\tilde{H}_{12}} \\ \underset{m \times n}{\tilde{H}_{21}} & \underset{m \times m }{\tilde{H}_{22}} \end{bmatrix}, \quad
  J = \begin{bmatrix} \underset{n \times n}{J_1} & \underset{n \times m}0 \\ \underset{m \times n}0 & \underset{m \times m}{J_2} \end{bmatrix}.
\end{equation*}
$$

Then equation (9.71) becomes:

$$
\begin{align}
  \begin{bmatrix} \tilde{H}_{11} & \tilde{H}_{12} \\ \tilde{H}_{21} & \tilde{H}_{22} \end{bmatrix} \begin{bmatrix} x_t \\ y_t \end{bmatrix} &= \begin{bmatrix} J_1 & 0 \\ 0 & J_2 \end{bmatrix} \begin{bmatrix} \tilde{H}_{11} & \tilde{H}_{12} \\ \tilde{H}_{21} & \tilde{H}_{22} \end{bmatrix} \begin{bmatrix} \tilde{x}_t \\\tilde{y}_t  \end{bmatrix} + H^{-1}G a_{t} \\[1em]
  \Leftrightarrow \begin{bmatrix} \tilde{x}_{t+1} \\ \mathbb{E}_t[\tilde{y}_{t+1}] \end{bmatrix} &=
\begin{bmatrix} J_1 & 0 \\ 0 & J_2 \end{bmatrix} \begin{bmatrix} \tilde{x}_t \\\tilde{y}_t  \end{bmatrix} +
\begin{bmatrix} \Gamma_1 \\ \Gamma_2 \end{bmatrix} a_t \\[1em]
 \Leftrightarrow & \left\{ \begin{array} \tilde{x}_{t+1} &=  J_1 \tilde{x_t} + \Gamma_1 a_t\\
                                        \mathbb{E}_t[\tilde{y}_{t+1}] &= J_2 \tilde{y_t} + \Gamma_2 a_t
 \end{array}\right. , 
\end{align}
$$

where

$$
\begin{bmatrix} \tilde{x}_t \\ \tilde{y}_t \end{bmatrix} = \begin{bmatrix} \tilde{H}_{11} & \tilde{H}_{12} \\ \tilde{H}_{21} & \tilde{H}_{22} \end{bmatrix} \begin{bmatrix} x_t \\ y_t \end{bmatrix}, \tag{9.72}\\
\Gamma = \begin{bmatrix} \underset{n \times k}{\Gamma_1} \\ \underset{m \times k}{\Gamma_2} \end{bmatrix} = H^{-1}G.
$$

### Step 4. Solving $y_t$ Using Non-exploding Condition.

The lower block of the partition is expressed as:

$$
\mathbb{E}_t[\tilde{y}_{t+1}] = J_2 \tilde{y}_t + \Gamma_2 a_t.
$$
Assuming the exogenous shock process follows $a_{t+1} = \rho a_t + \epsilon_{t+1}$, where $\rho$ is a $k \times k$ matrix, we can derive the forward iterations step-by-step:

$$
\begin{align}
  \mathbb{E}_t[\tilde{y}_{t+2}] &= \mathbb{E}_t[\mathbb{E}_{t+1}[\tilde{y}_{t+2}]]  \\[1em]
  &= \mathbb{E}_t [J_2 \tilde{y}_{t+1} + \Gamma_2 a_{t+1}] \\[1em]
  &= J_2 (J_2 \tilde{y}_t + \Gamma_2 a_t) + \Gamma_2 \rho a_t \\[1em]

  &= J_2^2 \left[ \tilde{y}_t + (J_2^2)^{-1} (J_2 \Gamma_2 + \Gamma_2 \rho) a_t \right], \\[2em]
  \mathbb{E}_t[\tilde{y}_{t+3}] &= J_2^3 \left[ \tilde{y}_t + (J_2^3)^{-1} (J_2^2 \Gamma_2 + J_2 \Gamma_2 \rho + \Gamma_2 \rho^2) a_t \right], \\[2em]
  &\vdots \notag \\[1em]
  \mathbb{E}_t[\tilde{y}_{t+T}] &= J_2^T \left[ \tilde{y}_t + (J_2^T)^{-1} \left( \sum_{j=0}^{T-1} J_2^{T-1-j} \Gamma_2 \rho^j \right) a_t \right] \\[1em]
  &= J_2^T \left[ \tilde{y}_t + \left( \sum_{j=0}^{T-1} J_2^{-(j+1)} \Gamma_2 \rho^j \right) a_t \right].
\end{align}
$$

Observe that $J_2$ is a diagonal matrix with all elements **greater than 1**. Thus, in order for the system not to explode (Transversality Condition), the non-predetermined variables must satisfy:

$$
\tilde{y}_t = - \sum_{j=0}^{\infty} J_2^{-(j+1)} \Gamma_2 \rho^j a_t.
$$

To simplify the notation, we define the $m \times k$ coefficient matrix $\Omega$ such that:

$$
\tilde{y}_t = \Omega a_t, \quad \text{where} \quad \Omega = - \sum_{j=0}^{\infty} J_2^{-(j+1)} \Gamma_2 \rho^j.
$$

Note that if the shock persistence matrix $rho$ is a diagonal matrix, i.e. $\rho = \text{diag}(\rho_1, \dots, \rho_k)$, then the $(i, \ell)$-th entry of $\Omega$, denoted by $\omega_{i, \ell}$, is derived as follows:

$$
\begin{align}
  \omega_{i, \ell} &= - \sum_{j=0}^{\infty} (\lambda_{n+i})^{-(j+1)} \gamma_{i, \ell} (\rho_\ell)^j \\[1em]
  &= - \frac{\gamma_{i, \ell}}{\lambda_{n+i}} \sum_{j=0}^{\infty} \left( \frac{\rho_\ell}{\lambda_{n+i}} \right)^j \\[1em]
  &= - \frac{\gamma_{i, \ell}}{\lambda_{n+i} - \rho_\ell},
\end{align}
$$

where $\gamma_{i, \ell}$ is the $(i, \ell)$-th entry of $\Gamma_2$.

Thus, the transformed system yields the relation $\tilde{y}_t = \Omega a_t$. Substituting $\tilde{y}_t$ back with $x_t$ and $y_t$, the jumping variables $y_t$ must satisfy:

$$
\Omega a_t = \tilde{H}_{21} x_t + \tilde{H}_{22} y_t.
$$

Solving for $y_t$, we obtain:

$$
\begin{align}
  y_t &= -\tilde{H}_{22}^{-1} \tilde{H}_{21} x_t + \tilde{H}_{22}^{-1} \Omega a_t \\[1em]
    &= A x_t + B a_t.
\end{align}
$$

Finally, substituting this decision rule into the transition equation for the predetermined variables $x_t$:

$$
\begin{align}
x_{t+1}
&= F_{11} x_t + F_{12} y_t + G_1 a_t \\[1em]
&= \left(F_{11} - F_{12} \tilde{H}_{22}^{-1} \tilde{H}_{21} \right) x_t + \left( G_1 + F_{12} \tilde{H}_{22}^{-1} \Omega \right) a_t \\[1em]
&= C x_t + D a_t.
\end{align}
$$

### Step 5. Impulse Response

< Derivation in iPad Note>

Thus, we have obtained the solution to the dynamic linear system under the Blanchard-Kahn framework as follows:

$$
\begin{align}
  y_{t+1} &=A x_{t+1} + B a_{t+1} \\[1em]
  &=A (C x_t + D a_t) + \rho B a_t \\[1em]
  &=AC x_t + (D + \rho B )a_t \\[1em]
\end{align}
$$

$$
\begin{align}
  \begin{bmatrix} x_{t+1} \\ y_{t+1} \end{bmatrix} &=  \begin{bmatrix} C & 0 \\ AC & 0 \end{bmatrix} \begin{bmatrix} x_t \\ y_t  \end{bmatrix} + \begin{bmatrix} D \\ D + \rho B \end{bmatrix} a_{t}\\[1em]
  y_0 &= A x_0 + B a_0.
\end{align}
$$

### R code

```{r SET bk function}
my_blanchard_kahn <- function(A_matrix, B_matrix, E_matrix = NULL, rho = 0) {
  # Refined Blanchard-Kahn Solver: Supports named indexing and n=0 cases
  # Solution form: y_t = sol_ytxt * x_t + sol_ytat * a_t
  
  my_ifelse <- function(test, yes, no){if(test){return(yes)}else{return(no)}}
  
  # --- 1. Initial Setup and Integrity Checks ---
  if ((dim(A_matrix)[[1]] != dim(A_matrix)[[2]]) | (dim(B_matrix)[[1]] != dim(B_matrix)[[2]]) | (dim(A_matrix)[[1]] != dim(B_matrix)[[1]])) {
    stop("Matrix A and B must be square matrices with the same dimensions.")
  }
  if(is.null(colnames(A_matrix))){
    stop("A matrix must have variable names in columns.")
  }

  n_vars_all <- NCOL(A_matrix)
  vars_all <- colnames(A_matrix)
  
  if(is.null(E_matrix)) {
    E_matrix <- matrix(0, n_vars_all, 1)
    colnames(E_matrix) <- "shock"
  }
  k <- NCOL(E_matrix)
  shk_names <- colnames(E_matrix)
  
  # Prepare rho as a vector for element-wise Omega calculation
  rho_vec <- if(length(rho) == 1) rep(rho, k) else rho
  
  # Initialize all potential solution objects to NULL
  sol_ytxt <- sol_ytat <- sol_xt1xt <- sol_xt1at <- sol_yt1xt <- sol_yt1at <- NULL
  sol_t1t <- sol_t1a <- sol_tt <- sol_ta <- NULL

  # --- 2. System Reduction (E. Sims) ---
  cat("### System Reduction following E. Sims ### \n")
  vars_q <- as_tibble(B_matrix, rownames = "variable") %>% 
    filter(if_all(-variable, function(x){x == 0})) %>% 
    pluck("variable")
  
  q <- length(vars_q)
  vars_nm <- setdiff(vars_all, vars_q)
  
  if(q > 0) {
    cat("   The following", q, "variable(s) are redundant:", "\n", vars_q, "\n")
    A_nm_nm <- A_matrix[vars_nm, vars_nm]
    A_nm_q  <- A_matrix[vars_nm, vars_q]
    A_q_nm  <- A_matrix[vars_q, vars_nm]
    A_q_q   <- A_matrix[vars_q, vars_q]
    B_nm_nm <- B_matrix[vars_nm, vars_nm]
    B_nm_q  <- B_matrix[vars_nm, vars_q]
    E_nm    <- E_matrix[vars_nm, , drop = FALSE]
    
    Psi <- -solve(A_q_q) %*% A_q_nm
    F_matrix <- solve(B_nm_nm + B_nm_q %*% Psi) %*% (A_nm_nm + A_nm_q %*% Psi)
    G_matrix <- solve(B_nm_nm + B_nm_q %*% Psi) %*% E_nm
  } else {
    cat("   No redundant variables are found. \n")
    F_matrix <- solve(B_matrix) %*% A_matrix
    G_matrix <- solve(B_matrix) %*% E_matrix
  }
  
  # Ensure F and G have consistent names
  dimnames(F_matrix) <- list(vars_nm, vars_nm)
  dimnames(G_matrix) <- list(vars_nm, shk_names)

  # --- 3. Decomposition and Stability Analysis ---
  cat("\n### Solving Model by Blanchard-Kahn Method ### \n")
  eig_result <- eigen(F_matrix)
  
  # Identification: Modulus >= 1 are non-predetermined
  m <- sum(Mod(eig_result$values) >= 1.000001) 
  n <- NCOL(F_matrix) - m
  
  idx_sort <- order(Mod(eig_result$values))
  sorted_eigenvalues <- eig_result$values[idx_sort]
  H <- eig_result$vectors[, idx_sort]
  
  # Assign names to H for traceability
  dimnames(H) <- list(vars_nm, vars_nm)
  
  # Group variable names
  x_names <- if(n > 0) vars_nm[1:n] else NULL
  y_names <- if(m > 0) vars_nm[(n+1):(n+m)] else NULL

  # Diagnostic Output
  cat("   ", n, " Predetermined     x(n): ", if(n > 0) x_names else "None", "\n")
  cat("   ", m, " Non-predetermined y(m): ", if(m > 0) y_names else "None", "\n")
  cat("   ", k, " Exogenous         (k): ", k, "\n")
  cat("    Sorted eigenvalues: ", round(sorted_eigenvalues, 4), "\n")
  
  # --- 4. Partitioning and Omega Derivation ---
  Hinv <- solve(H)
  J_2  <- sorted_eigenvalues[(n+1):(n+m)]
  
  Hinv_21 <- if(n > 0) Hinv[(n+1):(n+m), 1:n, drop=FALSE] else NULL
  Hinv_22 <- Hinv[(n+1):(n+m), (n+1):(n+m), drop=FALSE]
  
  Gamma   <- Hinv %*% G_matrix
  Gamma_2 <- Gamma[(n+1):(n+m), , drop=FALSE]
  
  # omega_{i,l} = - gamma_{i,l} / (lambda_{n+i} - rho_l)
  denom <- matrix(J_2, m, k) - matrix(rho_vec, m, k, byrow = TRUE)
  Omega <- - Gamma_2 / denom 
  dimnames(Omega) <- list(y_names, shk_names)
  
  # --- 5. Deriving Policy Functions ---
  Hinv_22_inv <- solve(Hinv_22)
  
  if(n > 0) {
    FF_11 <- F_matrix[1:n, 1:n, drop=FALSE]
    FF_12 <- F_matrix[1:n, (n+1):(n+m), drop=FALSE]
    G_1   <- G_matrix[1:n, , drop=FALSE]

    sol_ytxt  <- - Hinv_22_inv %*% Hinv_21          # Decision Rule A
    sol_ytat  <- Hinv_22_inv %*% Omega             # Decision Rule B
    sol_xt1xt <- FF_11 + FF_12 %*% sol_ytxt        # Transition C
    sol_xt1at <- G_1 + FF_12 %*% sol_ytat         # Transition D
    
    # Dynamics for IRFs
    sol_yt1xt <- sol_ytxt %*% sol_xt1xt
    sol_yt1at <- sol_ytxt %*% sol_xt1at + (matrix(rho_vec, m, k, byrow=TRUE) * sol_ytat)
    
    # Assembly with names
    sol_t1t <- cbind(rbind(sol_xt1xt, sol_yt1xt), matrix(0, n+m, m))
    sol_t1a <- rbind(sol_xt1at, sol_yt1at)
    sol_tt  <- sol_ytxt
    sol_ta  <- rbind(matrix(0, n, k), sol_ytat)
    
    # Restore names
    dimnames(sol_ytxt)  <- list(y_names, x_names)
    dimnames(sol_ytat)  <- list(y_names, shk_names)
    dimnames(sol_xt1xt) <- list(x_names, x_names)
    dimnames(sol_xt1at) <- list(x_names, shk_names)
    dimnames(sol_t1t)   <- list(vars_nm, vars_nm)
    dimnames(sol_t1a)   <- list(vars_nm, shk_names)
    dimnames(sol_tt)    <- list(y_names, x_names)
    dimnames(sol_ta)    <- list(vars_nm, shk_names)
    
  } else {
    # n = 0 case: only non-predetermined variables exist
    sol_ytat <- Hinv_22_inv %*% Omega
    dimnames(sol_ytat) <- list(y_names, shk_names)
    sol_ta   <- sol_ytat
    dimnames(sol_ta) <- list(y_names, shk_names)
  }
  
  # --- 6. Recover Redundant Variables (q > 0) ---
  if(q > 0) {
    if(n > 0) {
      Psi_x <- Psi[, 1:n, drop=FALSE]
      Psi_y <- Psi[, (n+1):(n+m), drop=FALSE]
      
      sol_qtxt  <- Psi_x + Psi_y %*% sol_ytxt
      sol_qtat  <- Psi_y %*% sol_ytat
      sol_qt1xt <- sol_qtxt %*% sol_xt1xt
      sol_qt1at <- sol_qtxt %*% sol_xt1at + (matrix(rho_vec, q, k, byrow=TRUE) * sol_qtat)
      
      sol_t1t <- cbind(rbind(sol_xt1xt, sol_yt1xt, sol_qtxt %*% sol_xt1xt), matrix(0, n+m+q, m+q)) # Simplified for IRF
      sol_tt  <- rbind(sol_ytxt, sol_qtxt)
      sol_t1a <- rbind(sol_xt1at, sol_yt1at, sol_qt1at)
      sol_ta  <- rbind(matrix(0, n, k), sol_ytat, sol_qtat)
      
      dimnames(sol_tt)  <- list(c(y_names, vars_q), x_names)
      dimnames(sol_t1a) <- list(vars_all, shk_names)
      dimnames(sol_ta)  <- list(vars_all, shk_names)
      dimnames(sol_t1t) <- list(vars_all, vars_all)
    } else {
      sol_qtat <- Psi %*% sol_ytat
      sol_ta   <- rbind(sol_ytat, sol_qtat)
      dimnames(sol_ta) <- list(vars_all, shk_names)
    }
  }

  # --- 7. Final Return List ---
  return(list(
    q = q, n = n, m = m, k = k, rho = rho,
    A = A_matrix, B = B_matrix, 
    FF = F_matrix, G = G_matrix,
    H = H, Hinv = Hinv, J = diag(sorted_eigenvalues),
    Gamma = Gamma, Omega = Omega, # Lambda renamed to Omega
    sol_ytxt = sol_ytxt, sol_ytat = sol_ytat, sol_xt1xt = sol_xt1xt, sol_xt1at = sol_xt1at,
    sol_yt1xt = sol_yt1xt, sol_yt1at = sol_yt1at,
    sol_t1t = sol_t1t, sol_t1a = sol_t1a, sol_ta = sol_ta, sol_tt = sol_tt
  ))
}
```


```{r SET bk function old}
my_blanchard_kahn_old <- function(A_matrix, B_matrix, E_matrix = NULL, rho = 0) {
  # Mukoyama macro pp 281
  #=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=
  # y{t+1} = F*y{t}+G
  # 
  #    n [x{t+1}]   n[J1  0]     n[x{t}]   [Gamma1][a{t}] 
  # => m [y{t+1}] = m[ 0 J2] %*% m[y{t}] + [Gamma2][a{t}]
  #          1         n  m         1
  #=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=
  # A_matrix <- A
  # B_matrix <- B
  # E_matrix <- E
  # rho <- 0
  
  my_ifelse <- function(test, yes, no){if(test){return(yes)}else{return(no)}}
  ### stop
  if ((dim(A)[[1]] != dim(A)[[2]])|(dim(B)[[1]] != dim(B)[[2]])|(dim(A)[[1]] != dim(B)[[1]]) ){stop("Matrix A and B must be the square matrices with the same dimensions.")}
  
  if(is.null(colnames(A_matrix))){stop("A matrix has to have the variable names on each column.")}

  ### fill optional E_matrix
  if ((dim(E)[[1]] != dim(A)[[1]])){stop("E has to have the same number of rows as A and B.")}
  if(is.null(E_matrix)){E_matrix <- matrix(data = rep(0, n_vars_all), nrow = n_vars_all)}
  if(is.null(colnames(E_matrix))){colnames(E_matrix) <- (1:dim(E_matrix)[[2]])}
  
  ### extract system information
  n_vars_all <- NCOL(A_matrix)
  vars_all <- colnames(A_matrix)
  k <- sum(colSums(abs(E_matrix))>0)
  shks_all <- my_ifelse(k > 0, colnames(E_matrix), NULL)

  ### system reduction following E. Sims lecture note
  cat("### System Reduction following E. Sims ### \n")
  vars_q <- as_tibble(B_matrix, rownames = "variable") %>% 
    filter(if_all(-variable, function(x){x == 0})) %>% 
    pluck("variable")
  q <- length(vars_q)
  vars_nm <- setdiff(vars_all, vars_q)
  
  if(q>0){
    cat("   The following", length(vars_q), "variable(s) are redundant:", "\n", vars_q)
    A_nm_nm <- A_matrix[vars_nm, vars_nm]
    A_nm_q <- A_matrix[vars_nm, vars_q]
    A_q_nm <- A_matrix[vars_q, vars_nm]
    A_q_q <- A_matrix[vars_q, vars_q]
    B_nm_nm <- B_matrix[vars_nm, vars_nm]
    B_nm_q <- B_matrix[vars_nm, vars_q]
    B_q_nm <- B_matrix[vars_q, vars_nm]
    B_q_q <- B_matrix[vars_q, vars_q]
    E_nm <- E_matrix[vars_nm,]
    E_q <- E_matrix[vars_q,]
    Psi <- -solve(A_q_q) %*% A_q_nm # E. Sims p. 
    F_matrix <- solve(B_nm_nm + B_nm_q %*% Psi) %*% (A_nm_nm + A_nm_q %*% Psi)
    G_matrix <- solve(B_nm_nm + B_nm_q %*% Psi) %*% E_nm
  } else{
    cat("   No redundant variables are found. \n")
    F_matrix <- solve(B_matrix) %*% A_matrix
    G_matrix <- solve(B_matrix) %*% E_matrix
  }

  ### Calculate eigenvalues and eigenvectors of the F matrix
  cat("\n")
  cat("### Solving Model by Blanchard-Kahn Method ### \n")
  eig_result <- eigen(F_matrix)
  m <- sum(eig_result$values>=1) # non-predetermined endogenous (y)
  n <- NCOL(F_matrix) - m # predetermined (x)
  sorted_eigenvalues <- eig_result$values[order(Mod(eig_result$values))]
  sorted_eigenvectors <- eig_result$vectors[, order(Mod(eig_result$values))]

  cat("   ", n, " Predetermined     x(n): ", vars_nm[1:n], "\n")
  cat("   ", m, " Non-predetermined y(m): ", vars_nm[(n+1):(n+m)], "\n")
  cat("   ", k, " Exogeneous         (k)", "\n")
  cat("   ", "Sorted eigenvalues: ", round(sorted_eigenvalues, 4),  "\n")
  
  ### Create partitioned F and G
  FF_11 <- my_ifelse(n > 0, F_matrix[1:n, 1:n, drop=F], NA_real_)
  FF_12 <- my_ifelse(n > 0, F_matrix[1:n, (n+1):(n+m), drop=F], NA_real_)
  FF_21 <- my_ifelse(n > 0, F_matrix[(n+1):(n+m), 1:n, drop=F], NA_real_)
  FF_22 <- F_matrix[(n+1):(n+m), (n+1):(n+m), drop=F]
  G_1 <- my_ifelse(n > 0, G_matrix[1:n, 1:k, drop=F], NA_real_)
  G_2 <- G_matrix[(n+1):(n+m), 1:k, drop=F]

  ### Create the H and J matrices based on the sorted results.
  H <- sorted_eigenvectors
  J <- diag(sorted_eigenvalues)
  dimnames(H) <- dimnames(J) <- list(rownames(F_matrix), colnames(F_matrix))
  Hinv <- solve(H)
  Hinv_11 <- my_ifelse(n > 0,  Hinv[1:n, 1:n, drop=F], NA_real_)
  Hinv_12 <- my_ifelse(n > 0, Hinv[1:n, (n+1):(n+m), drop=F], NA_real_)
  Hinv_21 <- my_ifelse(n > 0, Hinv[(n+1):(n+m), 1:n, drop=F], NA_real_)
  Hinv_22 <- Hinv[(n+1):(n+m), (n+1):(n+m), drop=F]
  J_1 <-  J[1:n, 1:n, drop=F]
  J_2 <- J[(n+1):(n+m), (n+1):(n+m), drop=F]
  ### shocks
  Gamma <- Hinv %*% G_matrix
  Gamma_1 <- my_ifelse(n > 0, Gamma[1:n,1:k, drop=F], NA_real_)
  Gamma_2 <- Gamma[(n+1):(n+m),1:k, drop=F]
  
  ### Deriving the Solution (pp.284)
  Lambda <- diag(-1/(diag(as.matrix(J_2))-rho), nrow = m)
  Hinv_22_inv <- solve(Hinv_22)
  if(n > 0){
    sol_ytxt <- - Hinv_22_inv %*% Hinv_21 ### A
    sol_ytat <- Hinv_22_inv %*% Lambda %*% Gamma_2 ### B
    sol_xt1xt <- FF_11 - FF_12 %*% (-sol_ytxt) ### C
    sol_xt1at <- G_1 + FF_12 %*% sol_ytat ### D
    ### for irf
    sol_yt1xt <- sol_ytxt %*% sol_xt1xt ### A %*% C
    sol_yt1at <- sol_ytxt %*% sol_xt1at + rho * sol_ytat ### B %*% rho + D
    ### irf block
    sol_t1t <- cbind(rbind(sol_xt1xt, sol_yt1xt), matrix(0, nrow =n+m, ncol = m))
    sol_t1a <- rbind(sol_xt1at, sol_yt1at)
    sol_tt <- sol_ytxt
    sol_ta <- rbind(matrix(0, nrow = n, ncol = max(k, 1)), sol_ytat)
    dimnames(sol_t1t) <- list(rownames(F_matrix), colnames(F_matrix))
    dimnames(sol_t1a) <- dimnames(sol_ta) <- list(rownames(F_matrix), rep("shock", k))
  } else{
    sol_ytat <- - Hinv_22_inv %*% Lambda %*% Gamma_2
    sol_ytxt <- sol_xt1xt <- sol_xt1at <- NULL
    sol_yt1xt <- sol_yt1at <- NULL
    ### irf block
    sol_t1t <- sol_t1a <- sol_tt <- NULL
    sol_ta <- sol_ytat
  }
  
  if(q > 0){
    ### y = m + q (redundant var)
    if(n > 0){
      ### derive q
      sol_qtxt <- Psi[, (1:n)] + Psi[,(n+1):(n+m)] %*% sol_ytxt #Sims p.16
      sol_qtat <- Psi[,(n+1):(n+m)] %*% sol_ytat # derived by myself
      sol_qt1xt <- sol_qtxt %*% sol_xt1xt ### A %*% C
      sol_qt1at <- sol_qtxt %*% sol_xt1at + rho * sol_qtat ### B %*% rho + D
      ### irf block
      sol_t1t <- cbind(rbind(sol_xt1xt, sol_yt1xt, sol_qt1xt), matrix(0, n+m+q, ncol = m+q))
      sol_tt <- rbind(sol_ytxt, sol_qtxt)
      sol_t1a <- rbind(sol_xt1at, sol_yt1at, sol_qt1at)
      sol_ta <- rbind(matrix(0, nrow = n, ncol = max(1, k)), sol_ytat, sol_qtat)
      dimnames(sol_t1t) <- list(vars_all, vars_all)
      dimnames(sol_t1a) <- dimnames(sol_ta) <- list(vars_all, rep("shock", k))
    } else {
      stop("Not prepared to solve the model with n = 0 and q > 0")
    }
  }
    
  # Return the results in a named list for clarity.
  result <- list(
    # setup
    q = q, n = n, m = m, k = k,
    rho = rho,
    A = A_matrix, B = B_matrix, 
    # transformation
    FF = F_matrix, FF_11 = FF_11, FF_12 = FF_12, FF_21 = FF_21, FF_22 = FF_22, 
    G = G_matrix, G_1 = G_1, G_2 = G_2,
    H = H,
    Hinv = Hinv, Hinv_11 = Hinv_11, Hinv_12 = Hinv_12,  Hinv_21 = Hinv_21, Hinv_22 = Hinv_22, 
    J = J, J_1 = J_1, J_2 = J_2,
    Gamma = Gamma, Gamma_1 = Gamma_1, Gamma_2 = Gamma_2, 
    # solution
    Lambda = Lambda,
    sol_ytxt = sol_ytxt, sol_ytat = sol_ytat, sol_xt1xt = sol_xt1xt, sol_xt1at = sol_xt1at,
    sol_yt1xt = sol_yt1xt, sol_yt1at = sol_yt1at,
    sol_t1t = sol_t1t,
    sol_t1a = sol_t1a,
    sol_ta = sol_ta,
    sol_tt = sol_tt
  )
  return(result)
}
```

## 2. Schur Decomposition

When $A$ in \@ref(eq:9.69) is not invertible, **Schur decomposition** can be used instead.

### R code

```{r SET schur function}
my_schur_decomp <- function(A_matrix, B_matrix){
  ### Based on ABCs of RBCs Chap. 6 App. 2  
  # A_matrix <- B
  # B_matrix <- A
  
  strs_var <- rownames(A_matrix)
  # Schur decomposition (using geigen library)
  ### Calculate the decomposition
  schur <- geigen::gqz(A_matrix, B_matrix, sort = "S")
  n <- schur$sdim  ### predetermined (x)
  m <- NROW(B_matrix) - n ### non-predetermined (y)
  sorted_eigenvalues <- diag(schur$S)/diag(schur$T)
  
  cat("### Solving the model by Schur Decomposition ###", "\n")
  cat("   ", n, "Predetermined x(n)", "\n")
  cat("   ", m, "Non-predetermined y(m)", "\n")
  cat("   ", "Sorted eigenvalues: ", round(sorted_eigenvalues, 4),  "\n")

  ### create Partitioned A & B
  B_11 <- B_matrix[1:n, 1:n, drop = F]
  B_12 <- B_matrix[1:n, (n+1):(n+m), drop = F]
  B_21 <- B_matrix[(n+1):(n+m), 1:n, drop = F]
  B_22 <- B_matrix[(n+1):(n+m), (n+1):(n+m), drop = F]
  A_11 <- A_matrix[1:n, 1:n, drop = F]
  A_12 <- A_matrix[1:n, (n+1):(n+m), drop = F]
  A_21 <- A_matrix[(n+1):(n+m), 1:n, drop = F]
  A_22 <- A_matrix[(n+1):(n+m), (n+1):(n+m), drop = F]
  
  ### create Zt based on the schur decomposition
  Zt <- t(schur$Z)
  dimnames(Zt) <- list(strs_var, strs_var)
  # schur$Q %*% schur$T %*% Zt %>% round(4) # QTZ' = B ### chk 1
  # schur$Q %*% schur$S %*% Zt %>% round(4) # QSZ' = A ### chk 2
  Zt_11 <- Zt[1:n, 1:n, drop = F]
  Zt_12 <- Zt[1:n, (n+1):(n+m), drop = F]
  Zt_21 <- Zt[(n+1):(n+m), 1:n, drop = F]
  Zt_22 <- Zt[(n+1):(n+m), (n+1):(n+m), drop = F]
  
  # Deriving the solution
  sol_ytxt <- -MASS::ginv(Zt_22) %*% Zt_21 ### -N (p. 139)
  rownames(sol_ytxt) <- strs_var[(n+1):(n+m)]
  Bexp_inv <- MASS::ginv(B_11-B_12 %*% (-sol_ytxt))
  sol_xt1xt <- Bexp_inv %*% (A_11-A_12 %*% (-sol_ytxt)) ### C
  rownames(sol_xt1xt) <- strs_var[1:n]
  
  ### for irf
  sol_yt1xt <- sol_ytxt %*% sol_xt1xt
  sol_t1t <- cbind(rbind(sol_xt1xt, sol_yt1xt), matrix(0, nrow =n+m, ncol = m))
  dimnames(sol_t1t) <- list(rownames(A_matrix), colnames(A_matrix))
  
  result <- list(
    # setup
    m = m, n = n,
    A = A_matrix, A_11 = A_11, A_12 = A_12, A_21 = A_21, A_22 = A_22,
    B = B_matrix, B_11 = B_11, B_12 = B_12, B_21 = B_21, B_22 = B_22,
    # schur decomp
    Zt = Zt, Zt_11 = Zt_11, Zt_12 = Zt_12, Zt_21 = Zt_21, Zt_22 = Zt_22,
    # solution
    sol_ytxt = sol_ytxt, sol_xt1xt = sol_xt1xt,
    sol_yt1xt = sol_yt1xt,
    sol_t1t = sol_t1t
  )
}
```


## 3. Sims Method

Sims Rational Expectation Model based on ...

- Sims 2002

- Dave and Dejong

- 藤原、渡部

$$
\begin{equation}
    \Gamma_0 \mathbf{y}_t = \Gamma_1 \mathbf{y}_{t-1} + \mathbf{C} + \Psi \mathbf{z}_t + \Pi \boldsymbol{\eta}_t
\end{equation}
$$

- $\mathbf{y}(t)$: $n \times 1$ vector of endogenous variables.

- $\mathbf{z}(t)$: $k \times 1$ vector of exogenous shock processes.

- $\boldsymbol{\eta}(t)$: $n \times 1$ vector of expectational errors, with $E_{t-1}[\boldsymbol{\eta}(t)] = \mathbf{0}$.

- $\Gamma_0, \Gamma_1$: $n \times n$ parameter matrices.

- $\mathbf{C}$: $n \times 1$ vector of constants.

- $\Psi$: $n \times k$ matrix of shock impacts.

- $\Pi$: $n \times 1$ vector of expectational error impacts.

$$
\mathbf{Q}' \Gamma_0 \mathbf{Z} = \Lambda \quad \text{and} \quad \mathbf{Q}' \Gamma_1 \mathbf{Z} = \Theta
$$

where $\mathbf{Q}$ and $\mathbf{Z}$ are unitary matrices, and $\Lambda$ and $\Theta$ are upper-triangular. The decomposition is ordered such that the generalized eigenvalues $\lambda_i/\theta_i$ with modulus greater than 1 (unstable roots) are grouped in the bottom-right block.

### R code

```{r SET sims function}
### get the num of systems
my_sims <- function(Gamma_0, Gamma_1, Psi, Pi){
  # Gamma_0 <- Gamma_0
  # Gamma_1 <- Gamma_1
  # Psi <- Psi
  # Pi <- Pi
  
  if(any(dim(Gamma_0) != dim(Gamma_1))){stop("Gamma_0 and Gamma_1 have different dimensions!!!")}
  n_all <- NCOL(Gamma_0)
  n_shk <- NCOL(Psi)
  n_err <- NCOL(Pi)
  
  ### get the names of systems ###
  if(is.null(colnames(Gamma_0))){stop("give the variables name to the column of Gmma_0!!!")}
  if(any(colnames(Gamma_0)!=colnames(Gamma_1))){warning("Gamma_0 and Gamma_1 have different column names. colnames(Gamma_0) are used as the variables name")}
  if(is.null(colnames(Psi))){colnames(Psi) <- str_c("shock", 1:n_shk)}
  if(is.null(colnames(Pi))){colnames(Pi) <- str_c("eerr", 1:n_err)}
  vars_all <- colnames(Gamma_0)
  vars_shk <- colnames(Psi)
  vars_err <- colnames(Pi)
  
  ### Schur decomposition ###
  # schur <- geigen::gqz(Gamma_1, Gamma_0, sort = "S")
  schur <- QZ::ordqz(Gamma_1, Gamma_0, keyword = "udi")
  Q <- t(schur$Q) # get aligned with Sims (32)
  Z <- schur$Z
  Omega <- schur$S # Gamma_1
  Lambda <- schur$T # Gamma_0
  geigen <- diag(Omega)/diag(Lambda) ### or geigen::gevalues(schur)
  geigen %>% round(2)
  
  schur_1 <- QZ::ordqz(Gamma_1, Gamma_0, keyword = "udi")
  Q_1 <- t(schur_1$Q) # get aligned with Sims (32)
  Z_1 <- schur_1$Z
  Omega_1 <- schur_1$S # Gamma_1
  Lambda_1 <- schur_1$T # Gamma_0
  geigen_1 <- diag(Omega_1)/diag(Lambda_1) ### or geigen::gevalues(schur)
  idx_1 <- order(abs(geigen_1), na.last = T)
  geigen_1[idx_1]

  
  ### predetermined v.s. non-predetermined ###
  n <- sum(abs(geigen) < 1)  ### predetermined
  m <- n_all - n ### non-predetermined
  if (m == 0) {warning("No unstable roots found. The system may have multiple solutions.")}
  if (n == 0) {warning("No stable roots found. The system has no stable solution.")}
  
  cat("Solving by Sims", "\n")
  cat("Predetermined x(n): ", n, "\n")
  cat("Non-predetermined y(m): ", m, "\n")
  
  ### check (Sims eq. 32) ###
  round(t(Q) %*% Lambda %*% t(Z), 4) == round(Gamma_0, 4)
  round(t(Q) %*% Omega %*% t(Z), 4) == round(Gamma_1, 4)
  
  ### prepare to solve the system ###
  Omega_11 <- Omega[1:n, 1:n]
  Lambda_11 <- Lambda[1:n, 1:n]
  Lambda_11_inv <- MASS::ginv(Lambda_11)
  Q_1 <- Q[1:n,]
  Q_2 <- Q[(n+1):(n+m),]
  ZZ <- t(Z) # my definition
  
  ### solve based on Fujiwara and Watanabe ###
  ##### relationship btw eta and shock (Fujiwara eq. 44)
  eerr_shk <- -(MASS::ginv(Q_2 %*% Pi)) %*% Q_2 %*% Psi %>% 
    `rownames<-`(vars_err)
  ##### follow Fujiwara and Watanabe (eq. 45) -> Great!!!
  AA <- Lambda_11_inv %*% Omega_11
  BB <- Lambda_11_inv %*% Q_1 %*% (Psi + Pi %*% eerr_shk)
  A <- rbind(cbind(AA, matrix(0, n, m)), matrix(0, m, n+m)) %>% 
    `colnames<-`(vars_all)
  B <- rbind(BB, matrix(0, m, 1)) # column: n of shock
  ##### final
  Theta_1 <- Z %*% A %*% ZZ %>% `colnames<-`(vars_all) # inv(ZZ)=t(ZZ)=Z 
  Theta_0 <- Z %*% B
  
  ### return ###
  ret <- list(Gamma_0 = Gamma_0, Gamma_1 = Gamma_1, Psi = Psi, Pi = Pi,
              n_var = n_all, n_n = n, n_m = m, n_shk = n_shk, n_err = n_err, 
              Theta_1 = Theta_1, Theta_0 = Theta_0)
  return(ret)
}
```

!!! redundant を解く!?

```{r, eval = F}
Gamma_1=Gamma_1[1:23,]
Gamma_0=Gamma_0[1:23,]
Psi <- Psi[1:23,]
Pi <- Pi[1:23,]
eqs_all <- 1:NROW(Gamma_0)
vars_all <- colnames(Gamma_0)
cat("\n ### System Reduction following E. Sims ### \n")
# redundant equations
eqs_r <- which(rowSums(abs(cbind(Gamma_1, Psi, Pi))) == 0)
# vars in redundant equations
vars_r <- intersect(colSums(abs(Gamma_0[eqs_r, ])) %>% .[. != 0] %>% names(),
                    colSums(abs(Gamma_0[eqs_n, ])) %>% .[. == 0] %>% names()
eqs_n <- setdiff(eqs_all, eqs_r)
vars_n <- setdiff(vars_all, vars_r)
  
  if(length(eqs_q)>0){
    cat("   The following", length(eqs_q), "equation(s) are redundant:", "\n", eqs_q)
    G0_n_n <- Gamma_0[eqs_n, vars_n]
    G0_n_r <- Gamma_0[eqs_n, vars_r]
    G0_r_n <- Gamma_0[eqs_r, vars_n]
    G0_r_r <- Gamma_0[eqs_r, vars_r]
    G1_n_n <- Gamma_1[eqs_n, vars_n]
    G1_n_r <- Gamma_1[eqs_n, vars_r]
    G1_r_n <- Gamma_1[eqs_r, vars_n]
    G1_r_r <- Gamma_1[eqs_r, vars_r]
    Psi_n <- Psi[eqs_n,]
    Psi_r <- Psi[eqs_r,]
    Pi_n <- Psi[eqs_n,]
    Pi_r <- Psi[eqs_r,]
    coef <- -MASS::ginv(G0_r_r) %*% G0_r_n # E. Sims p. 
    new_G0 <- G0_n_n + G0_n_r %*% coef
    new_G1 <- G1_n_n + G1_n_r %*% coef

  } else{
    cat("   No redundant variables are found. \n")
    F_matrix <- solve(Gamma_1) %*% Gamma_0
    G_matrix <- solve(Gamma_1) %*% E_matrix
  }
```

# Part II. Application

## 1. IS-LM Model

### (a). A Simple IS-LM Model

#### Model Description

$$
\begin{align}
  \text{IS Curve:} \quad
  x_t &= \mathbb{E}_t x_{t+1} - \frac{1}{\sigma} \left( i_t - \mathbb{E}_t \pi_{t+1} \right) + \varepsilon_t^x  \quad 
  \text{Gali (22), pp49}\\[1em]
  \text{New Keynesian Phillips Curve:} \quad
  \pi_t &= \beta \mathbb{E}_t \pi_{t+1} + \kappa x_t + \varepsilon_t^\pi \\[1em]
  \text{Monetary Policy Rule (NO SHOCK!!!):} \quad
  i_t &= \phi_\pi \pi_t + \phi_x x_t
\end{align}
$$

Plugging the monetary policy rule into IS curve,

$$
\begin{cases}
  x_t &= \mathbb{E}_t x_{t+1} - \frac{1}{\sigma} \left( \left( \phi_\pi \pi_t + \phi_x x_t \right) - \mathbb{E}_t \pi_{t+1} \right) + \epsilon_t^d  \\[1em]
  \pi_t &= \beta \mathbb{E}_t \pi_{t+1} + \kappa x_t + \epsilon_t^s
\end{cases}
$$

$$
\Leftrightarrow \begin{cases}
    \mathbb{E}_t x_{t+1} + \mathbb{E}_t \pi_{t+1} &= (1 + \phi_x) x_t + \phi_\pi \pi_t - \epsilon_t^d  \\[1em]
    \beta \mathbb{E}_t \pi_{t+1}  &=  - \kappa x_t + \pi_t - \epsilon_t^s
\end{cases}
$$

or

$$
\begin{equation}
  B y_{t+1} = A y_{t} + E a_t \tag{9.67},
\end{equation}
$$

where

$$
\begin{align}
  y_{t} = \begin{bmatrix} x_{t} \\ \pi_{t} \end{bmatrix}, \quad
  a_{t} = \begin{bmatrix} \epsilon_{t}^d \\ \epsilon_{t}^s \end{bmatrix}, \quad
  B = \begin{bmatrix} 1 , & 1\\ 0, & \beta \end{bmatrix}, \quad
  A = \begin{bmatrix} 1 + \phi_{x}, & \phi_{\phi}\\ -\kappa, & 1\end{bmatrix}, \quad
  E = \begin{bmatrix} -1, & 0 \\ 0,& -1 \end{bmatrix}.
\end{align}
$$

```{r setup a, results='asis'}
# parameter
sigma <- 1
beta <- 0.99
kappa <- 0.5
phi_pi <- 1.5
phi_x <- 0.5

# define A, B, E
strs_var <- c("x", "pi")
B <- matrix(c(1, 1,
              0, beta), nrow = 2, byrow = TRUE)
A <- matrix(c(1 + phi_x, phi_pi,
              -kappa,      1), nrow = 2, byrow = TRUE)
E <- diag(c(-1,-1))
dimnames(A) <- dimnames(B) <- list(strs_var, strs_var)

# print
my_print_matrix_latex(list(B = B, A = A, E = E))
```

#### Solving Blanchard-Kahn

```{r bk a hand-written, class.source='fold-hide'}
### hand-written
# solving for y_{t+1}
FF <- solve(B) %*% A
G <- solve(B) %*% E

# Jordan Decomp
JJ <- diag(sort(eigen(FF)$value))
HH <-  cbind(eigen(FF)$vectors[,2]/eigen(FF)$vectors[[2,2]],
            eigen(FF)$vectors[,1]/eigen(FF)$vectors[[2,1]])
HHinv <- solve(HH)

# solution
GGamma <- HHinv %*% G
LLambda <- diag(-1/diag(JJ))

BB <- -(HH %*% LLambda %*% GGamma)
```


```{r bk a function}
### function (check)
bk_a <- my_blanchard_kahn(A_matrix = A, B_matrix = B, E_matrix = E, rho = 0)
```

#### Solution

The system only has non-predetermined variables. The variables are expressed as the linear combination of two exogenous shocks.

$$
\begin{align}
  \tilde{y}_{t+1} = J\tilde{y}_{t}  + \Gamma  a_t \quad \text{from (9.72)} \\[1em]
  \tilde{y}_t = H^{-1}y_t = \Lambda \Gamma a_t\\[1em]
  y_t = H \Lambda \Gamma a_t
\end{align}
$$

```{r bk a solution, results='asis'}
# check handwritten vs fun
my_print_matrix_latex(list(B = bk_a$sol_ytat, `B_{handwritten}` = BB)) 
```

## 2. BM Model

This chunk replicates the example of BM model in Azzimonti et al (2025). After the full model description is shown, the reduced model (exactly the same as in the textbook) and the full model are solved in turn. 

### Full Model Description

The BM model consists of the following 4 equations:

$$
\begin{array}{rcl}
  \text{Euler Equation:} & 
    \displaystyle \frac{1}{C_t} & = \mathbb{E}_t \left[ \beta \left( 1 + \alpha \exp(z_{t+1}) K_{t+1}^{\alpha - 1} H_{t+1}^{1 - \alpha} - \delta \right) \displaystyle \frac{1}{C_{t+1}} \right] &
    (9.57) \\[1em]
  \text{Labor Supply Condition:}&
    \displaystyle \frac{1}{C_t}(1 - \alpha) \exp(z_t) K_t^\alpha H_t^{-\alpha} & = \xi &
    (9.58) \\[1em]
  \text{Budget Constraint:} 
    & K_{t+1} + C_t & = \exp(z_t) K_t^\alpha H_t^{1 - \alpha} + (1 - \delta) K_t &
    (9.53) \\[1em]
  \text{Shock Process:} 
    & z_{t+1} & = \rho z_t + \epsilon_{t} & 
    (9.60)
\end{array}
$$

The **steady state** can be solved as follows assuming $\bar{z} =1$ :

$$ 
\begin{cases}
  \beta \left(1+ \alpha (\bar{K} / \bar{H})^{\alpha-1}-\delta\right) &= 1 \\[1em]
  \frac{1}{\bar{C}}(1 - \alpha) (\bar{K} / \bar{H})^{\alpha - 1} & = \xi \\[1em]
  K_{t+1} + C_t & = \exp(z_t) K_t^\alpha H_t^{1 - \alpha} + (1 - \delta) K_t
\end{cases}
$$

$$
\Leftrightarrow \begin{cases}
  \alpha (\bar{K} / \bar{H})^{\alpha-1} &= \frac{1}{\beta} + \delta - 1 \quad \text{(MPK)}\\[1em]
  {\bar{K} / \bar{H}} &= {\Big( \frac{\bar{MPK}}{\alpha} \Big)}^{\frac{1}{\alpha-1}} \\[1em]
  \xi &= \frac{1}{\bar{C}}(1 - \alpha) \Big( {\bar{K} / \bar{H}} \Big)^{\alpha - 1} \\[1em]
  \bar{C} &= \bar{K}^\alpha \bar{H}^{1-\alpha} - \delta\bar{K}
\end{cases}.
$$

```{r setup prm 2}
alpha <- 1/3 # p277
beta <- 0.99 # p277
delta <- 0.0233 # p277 ### typo!!!
Hbar <- 1/3 # p277
rho <- 0.95 # p284
```

```{r setup ss 2}
# steady state
MPKbar <- 1/beta + delta -1
KHbar <- (MPKbar/alpha)^(1/(alpha-1))
Kbar <- Hbar * KHbar
Ybar <- (Kbar)^alpha * (Hbar)^(1-alpha)
Cbar <- Ybar-delta*Kbar
# parameter (calculated)
xi <- (1/Cbar) * (1-alpha) * KHbar^(alpha)
```

```{r setup 2 print, class.source='fold-hide'}
tibble(
  Parameter = list(html("&alpha;"), html("&beta;"), html("&delta;"), html("&xi;"), html("&rho;")),
  " " = c("Capital Share", "Discount Rate", "Capital Depreciation", "Labor Supply Elas.", "Shock Persistence"),
  value = c(alpha, beta, delta, xi, rho)
)  %>% 
  my_gt_default(font_decimals = 2) %>% 
  tab_header(title = "Parameters")

tibble(
  Variable = c("Y (Output)", "C (Consumption)", "K (Capital)", "H (Labor)", "K/H", "MPK (Capital Prod.)"),
  Value = c(Ybar, Cbar, Kbar, Hbar, KHbar, MPKbar)
) %>% 
  my_gt_default(font_decimals = 2) %>% 
  tab_header(title = "Steady State")
```

### Linearized Form

Linearizing these equations,

$$
\begin{cases}
  \bar{K} k_{t+1} + \bar{C} c_t &= \bar{K}^\alpha \bar{H}^{1 - \alpha} 
\left( z_t + \alpha k_t + (1 - \alpha) h_t \right) 
+ (1 - \delta) \bar{K} k_t \\[1em]
  -c_t &= \mathbb{E}_t \left[ \beta \alpha \bar{K}^{\alpha - 1} \bar{H}^{1 - \alpha} 
  \left( z_{t+1} + (\alpha - 1) k_{t+1} + (1 - \alpha) h_{t+1} \right)
- c_{t+1} \right] \\[1em]
  h_t &= \displaystyle \frac{1}{\alpha} (z_t + \alpha k_t - c_t) \\[1em]
  \mathbb{E}_tz_{t+1} &= \rho z_t
\end{cases}
$$

### (b). 2 Endo. + 1 Exo. ver

#### Reduced Linearized System

Eliminating $h_t$ and $\mathbb{E}_tz_{t+1}$ from the above system, we get this 2-equation system plus one exogenous shock:

$$
\begin{cases}
  \bar{K} k_{t+1} &= \frac{\bar{Y}}{\alpha} z_t 
  + \left( \bar{Y} + (1 - \delta) \bar{K} \right) k_t 
  - \left( \frac{1 - \alpha}{\alpha} \bar{Y} + \bar{C} \right) c_t, &&{(9.60)} \\
  \Big(\beta (1-\alpha) \Big(\frac{\bar{K}}{\bar{H}}\Big)^{\alpha - 1} + 1\Big) \mathbb{E}_t [c_{t+1}] 
  &= \beta \Big(\frac{\bar{K}}{\bar{H}}\Big)^{\alpha - 1} \rho z_t + c_t. &&{(9.61)}
\end{cases}
$$

In the matrix form,

$$
\begin{equation}
  B \begin{bmatrix} k_{t+1} \\ \mathbb{E}_t [c_{t+1}] \end{bmatrix} = A \begin{bmatrix} k_t \\ c_t \end{bmatrix} + E z_t, \tag{9.67}
\end{equation}
$$

where

$$
\begin{align}
  B = \begin{bmatrix} 
    \bar{K} & 0 \\
    0 & \beta (1-\alpha) (\bar{K}/\bar{H})^{\alpha - 1} + 1
    \end{bmatrix}, \quad
  A = \begin{bmatrix} 
    \bar{Y} + (1 - \delta) \bar{K} & - \left( (1-\alpha) \bar{Y} / \alpha + \bar{C} \right) \\
    0 & 1 
    \end{bmatrix}, \quad
  E = \begin{bmatrix} 
    \bar{Y} / \alpha \\ 
    \beta (\bar{K}/\bar{H})^{\alpha - 1} \rho \end{bmatrix}.
  \end{align}
$$

```{r linear b, results='asis'}
strs_var <- c("k", "c")
B <- matrix(c(Kbar, 0, 
              0, beta*(1-alpha)*(KHbar^(alpha-1))+1), nrow = 2, byrow = T)
A <- matrix(c(Ybar + (1-delta)*Kbar, -(((1-alpha)*Ybar/alpha) + Cbar),
              0, 1), nrow = 2, byrow = T)
E <- matrix(c(Ybar/alpha, 
              beta*(KHbar^(alpha-1))*rho), nrow = 2, byrow = T)
dimnames(B) <- dimnames(A) <- list(strs_var, strs_var)
dimnames(E) <- list(strs_var, c("shock"))

my_print_matrix_latex(list(B = B, A = A, E = E))
```

#### Blanchard-Kahn

Calculate $F$ and $G$ and input them into my function.

```{r bk b}
# apply BK function
bk_b <- my_blanchard_kahn(A, B, E, rho)
```

#### Solution

**Both the state variable ($c_t$) and the future state variable ($k_{t+1}$) are expressed as the function of the state variables as of t.**

The result coincides with the textbook (pp. 284).

```{r solution b, results='asis'}
xt_code <- "\\begin{bmatrix} z_{t} \\\\ k_{t} \\end{bmatrix}"
xt1_code <- "k_{t+1}"
yt_code <- "c_{t}"

### yt -< xt, at
my_print_AxByCz_latex(yt_code, xt_code, B_mat = cbind(bk_b$sol_ytxt, bk_b$sol_ytat), round = 4)
### xt1 <- xt, at
my_print_AxByCz_latex(xt1_code, xt_code, B_mat = cbind(bk_b$sol_xt1xt, bk_b$sol_xt1at), round = 4)
```

#### Calculating IRF

The following code calculates the impulse response recursively.

```{r irf bkb hand-written, class.source='fold-hide'}
tbl_irf_b_hw <- tibble(t = 1:100,
                       z = 0.95^(0:99),
                       k = c(0, rep(NA_real_, 99)),
                       c = rep(NA_real_, 100)
  )

# initial
tbl_irf_b_hw[1, c("k", "c")] <- t(bk_b$sol_ta %*% as.matrix(tbl_irf_b_hw[1, "z"]))
# from 2 to end
for(tt in 2:100){
  tbl_irf_b_hw[tt, c("k", "c")] <- t(bk_b$sol_t1t %*% t(tbl_irf_b_hw[tt-1, c("k", "c")]) + bk_b$sol_t1a * tbl_irf_b_hw[[tt-1,c("z")]])
}

head(tbl_irf_b_hw)
# 
# ggplot(tbl_irf_b_hw, mapping = aes(x = t)) +
#   geom_line(mapping = aes(y = k, color = "k")) +
#   geom_point(mapping = aes(y = k, color = "k")) +
#   geom_line(mapping = aes(y = c, color = "c")) +
#   geom_point(mapping = aes(y = c, color = "c")) +
#   labs(color = "Variable", y = "Dev. from Steady State", title = "IRF (Hand-written)")
```

The hand-written result coincides with the result from the below `my_bk_irf` function (hidden in default).

```{r irf function, class.source='fold-hide'}
my_bk_irf <- function(bkobj,mat_init_a = NULL, mat_init_xt = NULL, TT = 10){
  
  ### debug
  # bkobj <- bk_d
  # mat_init_a <- NULL
  # mat_init_xt <- matrix(c(1, 0), nrow = 2)
  # TT = 10
  # box
  strs_var <- rownames(bkobj$sol_t1t)
  mat_irf <- matrix(NA, nrow = length(strs_var), ncol = TT)
  rownames(mat_irf) <- strs_var
  
  if(!is.null(mat_init_a) & is.null(mat_init_xt)){
    ### System with Exogenous
    cat("Impulse Response (System with Exogenous) \n")
    # init
    mat_x1 <- bkobj$sol_ta[1:bkobj$n, 1:1, drop = F] %*% mat_init_a
    mat_y1 <- bkobj$sol_ytat %*%  mat_init_a
    mat_irf[, 1] <- mat_t <- rbind(mat_x1, mat_y1)
    # exo
    mat_exo <- lapply(0:(TT-1),function(x){mat_init_a * (bkobj$rho)^x}) %>% 
      reduce(cbind)
    # loop
    for(tt in c(2:TT)){
      mat_irf[, tt] <- mat_t <- bkobj$sol_t1t %*% mat_t + bkobj$sol_t1a %*% mat_exo[,tt-1]
    }
  } else if(is.null(mat_init_a) & !is.null(mat_init_xt)){
    ### System without Exogenous
    cat("Impulse Response (System without Exogenous) \n")
    mat_x1 <- mat_init_xt
    mat_y1 <- bkobj$sol_tt %*%  mat_x1
    mat_irf[, 1] <- mat_t <- rbind(mat_x1, mat_y1)
    # loop
    for(tt in c(2:TT)){
      mat_irf[, tt] <- mat_t <- bkobj$sol_t1t %*% mat_t
    }
  }
  
  tbl_irf <- bind_cols(tibble(t = 1:TT), as_tibble(t(mat_irf)))
  obj <- list(irf = tbl_irf, bkobj = bkobj)
  return(obj)
}

my_schur_irf <- function(schobj, mat_init_xt, TT = 10){
  
  # schobj <- sch_c
  # mat_init_xt <- matrix(c(1, 0), nrow = 2)
  # TT = 10

  # box
  strs_var <- rownames(schobj$A)
  mat_irf <- matrix(NA, nrow = length(strs_var), ncol = TT)
  rownames(mat_irf) <- strs_var

  # System without Exogenous
  print("Impulse Response (System without Exogenous) \n")
  mat_x1 <- mat_init_xt
  mat_y1 <- schobj$sol_ytxt %*% mat_x1
  mat_irf[, 1] <- mat_t <- rbind(mat_x1, mat_y1)
  # loop
  for(tt in c(2:TT)){
    mat_irf[, tt] <- mat_t <- schobj$sol_t1t %*% mat_t
  }
  
  tbl_irf <- bind_cols(tibble(t = as.integer(1:TT)), as_tibble(t(mat_irf)))
  obj <- list(irf = tbl_irf, schobj = schobj)
  return(obj)
}

### Sims IRF tukuru

```

```{r irf b}
irf_b <- my_bk_irf(bk_b, mat_init_a = matrix(c(1)))
irf_b$irf %>% head(5)
```

### (c). Exogenous Shock ver.

#### Linearized System

Incorporating $z_t$ into the system ... 

$$
\begin{equation}
  B \begin{bmatrix} z_{t+1} \\ k_{t+1} \\ \mathbb{E}_t [c_{t+1}] \end{bmatrix} = A \begin{bmatrix} z_t \\ k_t \\ c_t \end{bmatrix} + E z_t, \tag{9.67}
\end{equation}
$$

where

$$
\begin{align}
  B = \begin{bmatrix} 1 & 0& 0 \\
                      0 & \bar{K} & 0 \\
                      -\beta(\bar{K}/\bar{H})^{\alpha - 1} & 0 & \beta (1-\alpha) (\bar{K}/\bar{H})^{\alpha - 1} + 1 \end{bmatrix}, \quad
  A = \begin{bmatrix} \rho & 0 & 0 \\
                      {\bar{Y}}/{\alpha} & \bar{Y} + (1 - \delta) \bar{K} & - \left( (1-\alpha) \bar{Y} / \alpha + \bar{C} \right) \\
                      0 & 0 & 1 \end{bmatrix}, \quad
  E = \begin{bmatrix} 0 \\ 0\\ 0  \end{bmatrix}.
  \end{align}
$$

```{r linear c, results = "asis"}
strs_var <- c("z", "k", "c")
B <- matrix(c(1, 0, 0, 
              0, Kbar, 0,
              -beta*(KHbar^(alpha-1)), 0, beta*(1-alpha)*(KHbar^(alpha-1))+1), nrow = 3, byrow = T)

A <- matrix(c(rho, 0, 0,
              Ybar/alpha, Ybar + (1-delta)*Kbar, -(((1-alpha)*Ybar/alpha) + Cbar), 
              0, 0, 1), nrow = 3, byrow = T)
E <- matrix(c(0, 0, 0), nrow = 3, byrow = T)

dimnames(B) <- dimnames(A) <- list(strs_var, strs_var)
dimnames(E) <- list(strs_var, c("shock"))

my_print_matrix_latex(list(B = B, A = A, E = E))
```

#### Blanchard-Kahn

```{r bk c}
# apply BK function
bk_c <- my_blanchard_kahn(A, B, E, 0)
```

#### Solution

The result coincides with the 2-equation system.

```{r solution c, results='asis'}
bk_c$sol_ytxt %>% to_bmatrix_latex(round = 4) %>% cat("$$ A_{ans} = ", ., "$$", sep = "")
bk_c$sol_xt1xt %>% to_bmatrix_latex(round = 4) %>% cat("$$ C_{ans} = ", ., "$$", sep = "")

xt_code <- "\\begin{bmatrix} z_{t} \\\\ k_{t} \\end{bmatrix}"
xt1_code <- "k_{t+1}"
yt_code <- "c_{t}"

### yt -< xt, at
my_print_AxByCz_latex(yt_code, xt_code, B_mat = cbind(bk_c$sol_ytxt[,2, drop = F], bk_c$sol_ytxt[, 1, drop = F]), round = 4)
### xt1 <- xt, at
my_print_AxByCz_latex(xt1_code, xt_code, B_mat = cbind(bk_c$sol_xt1xt[2,2], bk_c$sol_xt1xt[2,1]), round = 4)
```

#### Calculating IRF

The result coincides with (b).

```{r irf c}
irf_c <- my_bk_irf(bk_c, mat_init_x = matrix(c(1, 0), nrow = 2), TT = 100)
irf_c$irf %>% 
  head(5) %>% 
  my_gt_default(font_decimals = 2)
```

```{r irf c old, eval = F, include=F}
tbl_irf_c <- tibble(t = 1:100,
                    z = 0^(0:99),
                    k = c(0, rep(NA_real_, 99)),
                    c = rep(NA_real_, 100))

# initial
tbl_irf_c[1, "c"] <- bk_c$sol_ytxt %*% t(tbl_irf_c[1, c("z", "k")])
# 2 to last
for(tt in 2:100){tbl_irf_c[tt, c("z", "k", "c")] <- t(bk_c$sol_t1t %*% t(tbl_irf_c[tt-1, c("z", "k", "c")]))}

# graph
ggplot(tbl_irf_b, mapping = aes(x = t)) +
  geom_line(mapping = aes(y = k, color = "k")) +
  geom_line(mapping = aes(y = c, color = "c")) +
  labs(color = "Variable")
```

### (c2). Sims' Method

#### Sims Linearized System

By adding **2 expectation terms** ($\mathbb{E}_t [c_{t+1}], \mathbb{E}_t [z_{t+1}]$) ^[Do not forget to add the expectation for $z_t$!!!], the above BM model is described as the following 5-equation model:

$$
\begin{align}
  B \begin{bmatrix} z_{t+1} \\ k_{t+1} \\ \mathbb{E}_t [c_{t+1}] \end{bmatrix} &= A \begin{bmatrix} z_t \\ k_t \\ c_t \end{bmatrix} + E a_{t+1}, \tag{9.67} \\[1em]
  \Rightarrow \Gamma_0 \begin{bmatrix} z_{t} \\ k_{t} \\ c_t \\ \mathbb{E}_t [z_{t+1}] \\ \mathbb{E}_t [c_{t+1}] \end{bmatrix} &= \Gamma_1 \begin{bmatrix} z_{t-1} \\ k_{t-1} \\ c_{t-1} \\ \mathbb{E}_{t-1} [z_t] \\ \mathbb{E}_{t-1} [c_t] \end{bmatrix} + \Psi \varepsilon_{t} + \Pi \eta_{t},
\end{align}
$$

where

$$
\begin{align}
  \Gamma_0 = \begin{bmatrix} 1 & 0 & 0 & 0 & 0 \\
                      0 & \bar{K} & 0 & 0 & 0 \\
                      0 & 0 & -1 &  - \beta \Big(\displaystyle\frac{\bar{K}}{\bar{H}} \Big)^{\alpha - 1} & \beta (1-\alpha) \Big(\displaystyle\frac{\bar{K}}{\bar{H}}\Big)^{\alpha - 1} + 1 \\
                      1 & 0 & 0 & 0 & 0 \\
                      0 & 0 & 1 & 0 & 0 \end{bmatrix}, \quad
  \Gamma_1 &= \begin{bmatrix} \rho & 0 & 0 & 0 & 0 \\
                      \displaystyle \frac{\bar{Y}}{\alpha} & \bar{Y} + (1 - \delta) \bar{K} & -  \Big(\displaystyle\frac{1-\alpha}{\alpha}\Big) \bar{Y}+ \bar{C} & 0  & 0\\
                      0 & 0 & 0 & 1 & 0 \\
                      0 & 0 & 0 & 0 & 1 \end{bmatrix}, \quad \\[1em]
  \Psi = \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}, \quad
  \varepsilon_t = \begin{bmatrix} \varepsilon^z_t\end{bmatrix}, \quad
  \Pi &= \begin{bmatrix} 0 & 0 \\ 0 & 0 \\ 0 & 0 \\ 1 & 0 \\ 0 & 1 \end{bmatrix}, \quad
  \eta_t = \begin{bmatrix} \eta^z_t \\ \eta^c_t \end{bmatrix}.
  \end{align}
$$

```{r linear c sims, results = "asis"}
strs_var <- c("z", "k", "c", "Ez", "Ec")
Gamma_0 <- matrix(c(1, 0, 0, 0, 0,
                    0, Kbar, 0, 0, 0,
                    0, 0, -1, -beta*(KHbar^(alpha-1)), beta*(1-alpha)*(KHbar^(alpha-1))+1,
                    1, 0, 0, 0, 0,
                    0, 0, 1, 0, 0), nrow = 5, byrow = T)

Gamma_1 <- matrix(c(rho, 0, 0, 0, 0,
                    Ybar/alpha, Ybar+(1-delta)*Kbar, -(((1-alpha)*Ybar/alpha)+Cbar), 0, 0,
                    0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0,
                    0, 0, 0, 0, 1), nrow = 5, byrow = T)

Psi <- matrix(c(1, 0, 0, 0, 0), nrow = 5, byrow = T)
Pi <- matrix(c(0, 0, 0, 1, 0,
                 0, 0, 0, 0, 1), nrow = 5, byrow = F)

dimnames(Gamma_0) <- dimnames(Gamma_1) <- list(strs_var, strs_var)

my_print_matrix_latex(list("\\Gamma_0" = Gamma_0, "\\Gamma_1" = Gamma_1, "\\Psi" = Psi, "\\Pi" = Pi))
```

#### Solution

```{r sims c sims}
sims_c <- my_sims(Gamma_0, Gamma_1, Psi, Pi)
```

```{r solution c sims, results='asis'}
my_print_AxByCz_latex(
  x_code = "\\begin{bmatrix} z_{t} \\\\ k_{t} \\\\ c_{t}  \\\\ \\mathbb{E}_t z_{t+1}  \\\\ \\mathbb{E}_t c_{t+1} \\end{bmatrix}",
  y_code = "\\begin{bmatrix} z_{t-1} \\\\ k_{t-1} \\\\ c_{t-1} \\\\ \\mathbb{E}_{t-1} z_{t}  \\\\ \\mathbb{E}_{t-1} c_{t} \\end{bmatrix}",
  z_code = "\\varepsilon_t",
  A_mat = 1,
  B_mat = sims_c$Theta_1,
  C_mat = sims_c$Theta_0,
  round = 2
)
```

### (d). Full Model

This section solves **a redundant version** of (c) using Schur decomposition. Before proceeding, double-check the solution using (c) (non-redundant system). The result coincides with bk function version.

```{r schur check}
# schur decomp and irf
sch_c <- my_schur_decomp(A, B)
irf_c_sch <- my_schur_irf(sch_c, matrix(c(1, 0), nrow = 2))
```

```{r schur check print 1, results='asis'}
my_print_matrix_latex(list("A_{ans}^{Schur}" = sch_c$sol_t1t, "A_{ans}^{BK}" = bk_c$sol_t1t))
```

```{r schur check print 2}
irf_c$irf %>% head(5)
irf_c_sch$irf %>% head(5)
```

#### Linearized System

\< Derivation in iPad Note\>

$$
\begin{equation}
  B \begin{bmatrix} z_{t+1} \\ k_{t+1} \\ \mathbb{E}_t [c_{t+1}] \\ \mathbb{E}_t [h_{t+1}] \end{bmatrix} = A \begin{bmatrix} z_t \\ k_t \\ c_t \\ h_t\end{bmatrix} + E z_t, \tag{9.67}
\end{equation}
$$

where

$$
\begin{align}
  B = \begin{bmatrix} 1 & 0 & 0 & 0\\
                      0 & \bar{K} & 0 & 0\\
                      \beta\alpha(\bar{K}/\bar{H})^{\alpha - 1} & \beta\alpha(\bar{K}/\bar{H})^{\alpha - 1} (\alpha-1) & -1 & \beta\alpha(\bar{K}/\bar{H})^{\alpha - 1} (1-\alpha) \\
                      0 & 0 & 0 & 0\end{bmatrix}, \quad
  A = \begin{bmatrix} \rho & 0 & 0 & 0\\
                      \bar{Y} & \alpha\bar{Y} + (1-\delta)\bar{K} & -\bar{C} & (1-\alpha) \bar{Y}\\
                      0 & 0 & -1 & 0 \\
                      1/\alpha & 1 & -1/\alpha & -1\end{bmatrix}, \quad
  E = \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}.
  \end{align}
$$

```{r linear d old, eval = F, include = F, results = "asis"}
strs_var <- c("z", "k", "c", "h")

tmp <- beta * alpha * KHbar^(alpha-1)
B <- matrix(c(1, 0, 0, 0, 
              0, Kbar, 0, 0,
              tmp, tmp*(alpha-1), -1, tmp*(1-alpha),
              0, 0, 0, 0), nrow = 4, byrow = T)
A <- matrix(c(rho, 0, 0, 0,
              Ybar, alpha*Ybar + (1-delta)*Kbar, -Cbar, (1-alpha) * Ybar, 
              0, 0, -1, 0,
              1/alpha, 1, -1/alpha, -1), nrow = 4, byrow = T)
E <- matrix(c(0, 0, 0, 0), nrow = 4, byrow = T)

dimnames(B) <- dimnames(A) <- list(strs_var, strs_var)
dimnames(E) <- list(strs_var, c("shock"))

my_print_matrix_latex(list(B = B, A = A, E = E))
```

<!-- where -->

<!-- $$ -->
<!-- \begin{align} -->
<!--   B = \begin{bmatrix} 1 & 0 & 0 & 0\\ -->
<!--                       0 & \bar{K} & 0 & 0\\ -->
<!--                       \beta\alpha(\bar{K}/\bar{H})^{\alpha - 1} & \beta\alpha(\bar{K}/\bar{H})^{\alpha - 1} (\alpha-1) & -1 & \beta\alpha(\bar{K}/\bar{H})^{\alpha - 1} (1-\alpha) \\ -->
<!--                       0 & 0 & 0 & 0\end{bmatrix}, \quad -->
<!--   A = \begin{bmatrix} \rho & 0 & 0 & 0\\ -->
<!--                       \bar{Y} & \alpha\bar{Y} + (1-\delta)\bar{K} & -\bar{C} & (1-\alpha) \bar{Y}\\ -->
<!--                       0 & 0 & -1 & 0 \\ -->
<!--                       1/\alpha & 1 & -1/\alpha & -1\end{bmatrix}, \quad -->
<!--   E = \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}. -->
<!--   \end{align} -->
<!-- $$ -->

$$
\begin{align}
(1)\quad & z_{t+1} = \rho z_t \\
(4)\quad & k_{t+1} = \theta_1 y_t + \theta_2 k_t + \theta_3 c_t \\
(5)\quad & \mathbb{E}_t[c_{t+1}] = c_t + \text{(MPK等の係数項)} \\
(2)\quad & h_t = \frac{1}{\alpha}(z_t + \alpha k_t - c_t) \\
(3)\quad & y_t = z_t + \alpha k_t + (1 - \alpha) h_t \\
(6)\quad & \text{MPK}_t = y_t - k_t \\
(7)\quad & \text{MPL}_t = y_t - h_t
\end{align}
$$



```{r linear d, results = "asis"}
strs_var <- c("z", "k", "c", "h", "y", "mpk", "mpl")

tmp <- beta * alpha * KHbar^(alpha-1)
  
B <- matrix(c(1, 0, 0, 0, 0, 0, 0, 
              0, Kbar, 0, 0, 0, 0, 0,
              tmp, tmp*(alpha-1), -1, tmp*(1-alpha), 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0), nrow = 7, byrow = T)

A <- matrix(c(rho, 0, 0, 0, 0, 0, 0,
              0, (1-delta)*Kbar, -Cbar, 0, Ybar, 0, 0,
              0, 0, -1, 0, 0, 0, 0,
              1/alpha, 1, -1/alpha, -1, 0, 0, 0,
              1, alpha, 0, (1-alpha), -1, 0, 0,
              1, alpha-1, 0, 1-alpha, 0, -1, 0,
              1, alpha, 0, -alpha, 0, 0, -1), nrow = 7, byrow = T)
E <- matrix(c(0, 0, 0, 0, 0, 0, 0), nrow = 7, byrow = T)

dimnames(B) <- dimnames(A) <- list(strs_var, strs_var)
dimnames(E) <- list(strs_var, c("shock"))

my_print_matrix_latex(list(B = B, A = A, E = E))
```

#### Schur Decomposition

```{r schur d}
sch_d <- my_schur_decomp(A, B)
cat("\\n")
bk_d <- my_blanchard_kahn(A, B, E, 0)
```

```{r solution comparison d, results = "asis"}
my_print_matrix_latex(list("schur" = sch_d$sol_t1t, "bk" = bk_d$sol_t1t))
```

#### Solution

The result coincides with the 2-equation system.

```{r solution d, results='asis'}
sch_d$sol_ytxt %>% to_bmatrix_latex(round = 4) %>% cat("$$ A_{ans} = ", ., "$$", sep = "")
sch_d$sol_xt1xt %>% to_bmatrix_latex(round = 4) %>% cat("$$ C_{ans} = ", ., "$$", sep = "")

xt_code <- "\\begin{bmatrix} z_{t} \\\\ k_{t} \\end{bmatrix}"
xt1_code <- "\\begin{bmatrix} z_{t+1} \\\\ k_{t+1} \\end{bmatrix}"
yt_code <- "\\begin{bmatrix} c_{t} \\\\ h_{t}  \\\\ y_{t} \\\\ mpk_{t} \\\\ mpl_{t} \\end{bmatrix}"

### yt -< xt, at
my_print_AxByCz_latex(yt_code, xt_code, B_mat = sch_d$sol_ytxt, round = 4)
### xt1 <- xt, at
my_print_AxByCz_latex(xt1_code, xt_code, B_mat =sch_d$sol_xt1xt, round = 4)
```

#### IRF

```{r irf d}
irf_d <- my_schur_irf(sch_d, matrix(c(1, 0), nrow = 2), TT = 100)
irf_d_bk <- my_bk_irf(bk_d, mat_init_xt = matrix(c(1, 0), nrow = 2), TT = 100)
head(irf_d$irf, 5)
head(irf_d_bk$irf, 5)
```

### Discussion

#### Interpretation of IRFs

- To a unit productivity shock, $h_t$ and $y_t$ respond larger than unity. $y_t$ responds the largest because of the (i) **productivity effect** and (ii) **the increase in labor**. $c_t$ responds less than unity because of the **smoothing effect**.

- While $h_t$ turns to negative after a while because of the **substitution effect**, $y_t$ remains positive because **the lagged increase in capital**.

- Since $\sigma$ is set to 1, $mpl_t$ and $c_t$ show **one-to-one relationship**.

- The sensitivity to unit increase of $mpk_t$ in $z_t$ or $k_t$ are larger than those of $mpl_t$, reflecting that labor input can be **adjusted**.

```{r irf d graph, class.source='fold-hide'}
irf_d$irf %>% 
  pivot_longer(cols = -t, names_to = "Variable") %>% 
  filter(t <= 10) %>% 
  my_dplyr_indexmatch(mapping =list(c(c = 1, h = 1, k = 1, y = 1, mpk = 2, mpl = 2, z = 2)),
                      new_col_name = list("group"),
                      target_col = list("Variable")) %>% 
  ggplot() +
  geom_line(mapping = aes(x = t, y = value, color = Variable)) +
  geom_point(mapping = aes(x = t, y = value, color = Variable)) +
  geom_hline(yintercept = 0)+
  facet_wrap(~group, ncol = 1)
```

#### Relationship between Zt, Kt, and Ct

Consumption is high when (i) $z_t$ is high (the increase in future income) and (ii) $k_t$ is high (large output). While $z_t$ decreases monotonistically, the increase in $k_t$ contributes to push up the consumption for a longer horizon.

#### Why Consumption Responds Sluggishly?

The below heatmap shows the value of $c_t$ (*choice variable*) as a function of $z_t$ and $k_t$ (*pre-determined variables*).

```{r discussion graph, class.source='fold-hide'}
# ヒートマップ用グリッドを作成
grid <- expand.grid(z = seq(-0.2, 1.2, length.out = 100), 
                    k = seq(-0.2, 1.2, length.out = 100)) %>% 
  mutate(c = bk_c$sol_ytxt[["c","z"]] * z + bk_c$sol_ytxt[["c","k"]] * k)

# プロット
ggplot() +
  # 背景：ctのヒートマップ
  geom_tile(data = grid, aes(x = z, y = k, fill = c)) +
  scale_fill_gradientn(colors = terrain.colors(10)) +
  # 等高線
  geom_contour(data = grid, aes(x = z, y = k, z = c), breaks = c(0:4)/4, linetype = "dashed")+
  # 実際のkt/ztの時系列の軌跡を重ねる（線と点）
  geom_path(data = irf_c$irf, aes(x = z, y = k), color = "red", size = 1) +
  geom_point(data = irf_c$irf, aes(x = z, y = k), color = "red", size = 1) +
  # 軸などのラベル
  geom_hline(yintercept = 0)+
  geom_vline(xintercept = 0)+
  labs(x = "zt", y = "kt", fill = "ct")
```

#### Source of Sluggishness

In this simple RBC model, sluggishness is given by the **capital dynamics**. When the depreciation is very high, i.e. the stock of capital reflects economic conditions fast, the impulse responses depreciate fast.

```{r d alternative linear, class.source='fold-hide'}
# alternative parameter
delta <- 0.8
# re-calculate steady state
MPKbar <- 1/beta + delta -1
KHbar <- (MPKbar/alpha)^(1/(alpha-1))
Kbar <- Hbar * KHbar
Ybar <- (Kbar)^alpha * (Hbar)^(1-alpha)
Cbar <- Ybar-delta*Kbar
xi <- (1/Cbar) * (1-alpha) * KHbar^(alpha)

# re-define matrices
tmp <- beta * alpha * KHbar^(alpha-1)
B <- matrix(c(1, 0, 0, 0, 0, 0, 0, 
              0, Kbar, 0, 0, 0, 0, 0,
              tmp, tmp*(alpha-1), -1, tmp*(1-alpha), 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0), nrow = 7, byrow = T)
A <- matrix(c(rho, 0, 0, 0, 0, 0, 0,
              0, (1-delta)*Kbar, -Cbar, 0, Ybar, 0, 0,
              0, 0, -1, 0, 0, 0, 0,
              1/alpha, 1, -1/alpha, -1, 0, 0, 0,
              1, alpha, 0, (1-alpha), -1, 0, 0,
              1, alpha-1, 0, 1-alpha, 0, -1, 0,
              1, alpha, 0, -alpha, 0, 0, -1), nrow = 7, byrow = T)
E <- matrix(c(0, 0, 0, 0, 0, 0, 0), nrow = 7, byrow = T)

dimnames(B) <- dimnames(A) <- list(strs_var, strs_var)
dimnames(E) <- list(strs_var, c("shock"))

sch_d2 <- my_schur_decomp(A,B)
irf_d2 <- my_schur_irf(sch_d2, matrix(c(1, 0), nrow = 2), TT = 100)
```

```{r d alternative linear graph, class.source='fold-hide'}
# comparison graph
bind_rows(
  mutate(irf_d$irf, model = "baseline"),
  mutate(irf_d2$irf, model = "high delta")
  ) %>% 
  dplyr::select(t, k, c, y, model) %>% 
  pivot_longer(cols = c(k, c, y), names_to = "Variable") %>% 
  ggplot() +
  geom_line(mapping = aes(x = t, y = value, color = Variable, linetype = model)) +
  geom_hline(yintercept = 0)
```


（6/29 Part I BK methodの最後のAR1形式表示を追加して、またIRFの計算方法を確りと書き留めておく。ひとまず終えて、ABCs of RBCsに行く）
6/30 IRF Dynareとも一致！（Dynareでは定常状態からの乖離に引き直す）


### (BOTSU) (d). Hasumi RBC 

<!-- ### Model -->

<!-- The model consists of the following linearized equations: -->

<!-- $$ -->

<!-- \begin{align} -->

<!-- \hat{w}_t - \hat{c}_t &= \gamma \hat{l}_t \tag{6.57} \\ -->

<!-- \hat{c}_{t+1} - \hat{c}_t &= \beta R^* \hat{R}_{t+1} \tag{6.58} \\ -->

<!-- \hat{y}_t &= \hat{a}_t + \alpha \hat{k}_t + (1 - \alpha)\hat{l}_t \tag{6.59} \\ -->

<!-- \hat{w}_t &= \hat{a}_t + \alpha \hat{k}_t \tag{6.60} \\ -->

<!-- \frac{R^*}{R^* - 1} \hat{R}_{t+1} &= \hat{a}_t + (\alpha - 1)\hat{k}_t + (1 - \alpha)\hat{l}_t \tag{6.61} \\ -->

<!-- K^* \hat{k}_{t+1} &= Y^* \hat{y}_t + (1 - \delta) K^* \hat{k}_t - C^* \hat{c}_t \tag{6.62} \\ -->

<!-- \hat{a}_{t+1} &= \rho \hat{a}_t \tag{6.63} -->

<!-- \end{align} -->

<!-- $$ -->

<!-- The system can be expressed in the form $( B x_{t+1} = C x_t $), where: -->

<!-- $$ -->

<!-- \begin{align} -->

<!-- B &= -->

<!-- \begin{bmatrix} -->

<!-- 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ -->

<!-- 1 & 0 & 0 & 0 & 0 & -\beta R^* & 0 \\ -->

<!-- 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ -->

<!-- 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ -->

<!-- 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ -->

<!-- 0 & 0 & 0 & 0 & 0 & K^* & 0 \\ -->

<!-- 0 & 0 & 0 & 0 & 0 & 0 & 1 -->

<!-- \end{bmatrix} -->

<!-- \tag{6.64}\\ -->

<!-- C &= -->

<!-- \begin{bmatrix} -->

<!-- 1 & \gamma & 0 & -1 & 0 & 0 & 0 \\ -->

<!-- 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ -->

<!-- 1 & -\alpha & -1 & 0 & 0 & \alpha & 1 \\ -->

<!-- 0 & -\alpha & 0 & 0 & 1 & \alpha & 0 \\ -->

<!-- 1 & -\alpha & 0 & 0 & -\frac{R^*}{R^*-1} & \alpha -1 & 0 \\ -->

<!-- -C^* & 0 & Y^* & 0 & 0 & -(1-\delta)K^* & 0 \\ -->

<!-- 0 & 0 & 0 & 0 & 0 & 0 & \rho -->

<!-- \end{bmatrix} -->

<!-- \tag{6.65} -->

<!-- \end{align} -->

<!-- $$ -->

<!-- Hasumi間違っている…？ -->

<!-- ```{r} -->

<!-- # パラメータ（必要に応じて値を指定） -->

<!-- beta <- 0.99 -->

<!-- alpha <- 0.3 -->

<!-- gamma <- 1 -->

<!-- delta <- 0.025 -->

<!-- rho <- 0.9 -->

<!-- R_star <- 1.035 -->

<!-- K_star <- 14.3 -->

<!-- Y_star <- 1.67 -->

<!-- C_star <- 1.32 -->

<!-- # 行列 B（7x7） -->

<!-- A <- matrix(c( -->

<!--   0, 0, 0, 0, 0, K_star, 0, -->

<!--   0, 0, 0, 0, 0, 0, 1, -->

<!--   0, 0, 0, 0, 0, 0, 0, -->

<!--   1, 0, 0, 0, -beta * R_star, 0, 0, -->

<!--   0, 0, 0, 0, 0, 0, 0, -->

<!--   0, 0, 0, 0, 0, 0, 0, -->

<!--   0, 0, 0, 0, 0, 0, 0 -->

<!-- ), nrow = 7, byrow = TRUE) -->

<!-- # 行列 C（7x7） -->

<!-- B <- matrix(c( -->

<!--  -C_star, 0, Y_star, 0, 0, -(delta - 1) * K_star, 0, -->

<!--   0, 0, 0, 0, 0, 0, rho, -->

<!--   1, gamma, 0, -1, 0, 0, 0, -->

<!--   1, 0, 0,  0, 0, 0, 0, -->

<!--   0, 1-alpha, -1, 0, 0, alpha, 1, -->

<!--   0, -alpha, 0,-1, 0, alpha, 1, -->

<!--   0, 1-alpha, 0,  0, -R_star / (R_star - 1), alpha - 1, 0 -->

<!-- ), nrow = 7, byrow = TRUE) -->

<!-- E <- matrix(c(0, 1, 0, 0, 0, 0, 0), nrow = 7) -->

<!-- FF <- solve(B) %*% A -->

<!-- G <- solve(B) %*% E -->

<!-- bk <- my_blanchard_kahn(FF, G, 0) -->

<!-- ### Hasumi Method -->

<!-- # BB <- rbind(A[3:7,], A[1:2,]) -->

<!-- # CC <- rbind(B[3:7,], B[1:2,]) -->

<!-- # AA <- solve(CC) %*% BB -->

<!-- # eig_AA <- eigen(AA) -->

<!-- # eig_AA$values %>% round(2) -->

<!-- # eig_AA$vectors %>% round(2) -->

<!-- # sorted_eigenvalues %>% round(2) -->

<!-- # sorted_eigenvectors %>% round(2) -->

<!-- #  -->

<!-- # sorted_eigenvalues <- eig_AA$values[order(Mod(eig_AA$values))] -->

<!-- # sorted_eigenvectors <- eig_AA$vectors[, order(Mod(eig_AA$values))] -->

<!-- #  -->

<!-- # VV <- diag(sorted_eigenvalues) -->

<!-- # SS <- sorted_eigenvectors -->

<!-- # QQ <- solve(SS) -->

<!-- # QQinv <- SS -->

<!-- #  -->

<!-- # QQ %*% AA %*% QQinv %>% round(4) # check -->

<!-- #  -->

<!-- # # partition -->

<!-- # VV_x <- VV[1:5,1:5] -->

<!-- # VV_s <- VV[6:7,6:7] -->

<!-- #  -->

<!-- # QQ_A <- QQ[1:5,1:5] -->

<!-- # QQ_B <- QQ[1:5,6:7] -->

<!-- # QQ_C <- QQ[6:7,1:5] -->

<!-- # QQ_D <- QQ[6:7,6:7] -->

<!-- #  -->

<!-- # -solve(QQ_A) %*% QQ_B %>% round(2) # (6.56) xt = -(QA)^-1 %*% QB %*% st -->

<!-- #  -->

<!-- # QQ_A -->

<!-- # bk$Hinv_11 -->

<!-- #  -->

<!-- # QQ_B -->

<!-- # bk$Hinv_12 -->

<!-- ``` -->

## 3. Gali's NK Model

#### Model Description

$$
\begin{align}
  \text{New Keynesian Phillips Curve:} \quad
    \pi_t &= \beta \mathbb{E}_t \pi_{t+1} + \kappa \tilde{y}_t
    &&\text{Gali (21), pp49}\\[1em]
  \text{IS Curve:} \quad
    \tilde{y}_t &= \mathbb{E}_t \tilde{y}_{t+1} - \frac{1}{\sigma} (i_t - \mathbb{E}_t \pi_{t+1}  - r_t^n)
    &&\text{Gali (22), pp49}\\[1em]
  \text{Natural Rate:}\quad
    r_t^n &= \rho + \sigma \psi_{ya}^n \mathbb{E} \Delta a_{t+1}
    &&\text{Gali (23), pp49}\\[1em]
  \text{Simple Monetary Policy Rule:} \quad
    i_t &= \rho + ( \phi_\pi \pi_t + \phi_y \tilde{y}_t) + v_t
    &&\text{Gali (25), pp50}\\[1em]
\end{align}
$$

### (e). Constant $r^n$

#### Setup

Assuming no shocks than monetary policy we can delete the natural rate equation,

$$
\begin{align}
  \text{New Keynesian Phillips Curve:} \quad
    \pi_t &= \beta \mathbb{E}_t \pi_{t+1} + \kappa \tilde{y}_t
    &&\text{Gali (21), pp49}\\[1em]
  \text{IS Curve:} \quad
    \tilde{y}_t &= \mathbb{E}_t \tilde{y}_{t+1} - \frac{1}{\sigma} (\hat{i}_t - \mathbb{E}_t \pi_{t+1})
    &&\text{Gali (22), pp49}\\[1em]
  \text{Simple Monetary Policy Rule:} \quad
    \hat{i}_t &= \phi_\pi \pi_t + \phi_y \tilde{y}_t + v_t
    &&\text{Gali (25), pp50}\\[1em]
\end{align}
$$

Adding the dynamics of monetary policy shock, $v_t$, 

$$
\begin{align}
  \mathbb{E}_t v_{t+1} &= \rho v_t + \epsilon^v_t \\[1em]
  \beta \mathbb{E}_t \pi_{t+1} &= \pi_t- \kappa \hat{y}_t \\[1em]
  \ \mathbb{E}_t \pi_{t+1}  + \sigma \mathbb{E}_t \hat{y}_{t+1} &= \sigma \hat{y}_t + \hat{i}_t \\[1em]
  0 &= v_t + \phi_{\pi}\pi_t + \phi_y\hat{y}_t - \hat{i}_t
\end{align}
$$

or

$$
\begin{align}
  \mathbb{E}_t v_{t+1} &= \rho v_t + \epsilon^v_t \\[1em]
  \beta \mathbb{E}_t \pi_{t+1} &= \pi_t- \kappa \hat{y}_t \\[1em]
  \mathbb{E}_t \pi_{t+1} + \sigma \mathbb{E}_t \hat{y}_{t+1} &= v_t + \phi_{\pi}\pi_t + (\sigma + \phi_y)\hat{y}_t
\end{align}
$$

Rearranging in the matrix form,

$$
\begin{align}
  B y_{t+1} &= A y_{t} + E a_t \quad,
\end{align}
$$

where

$$
\begin{align}
  y_{t} = \begin{bmatrix} v_t \\ \pi_{t}  \\ \tilde{y}_t\end{bmatrix}, \quad
  B = \begin{bmatrix} 1 & 0 & 0 \\ 
                      0 & \beta & 0 \\
                      0 & 1 & \sigma \end{bmatrix}, \quad
  A = \begin{bmatrix} \rho_v & 0 & 0 \\
                      0 & 1 & -\kappa \\
                      1 & \phi_{\pi} & \sigma + \phi_{y} \end{bmatrix}, \quad
  E = \begin{bmatrix} 0 \\ 0 \\ 0 \end{bmatrix}.
\end{align}
$$

```{r setup 3}
strs_var <- c("mpshock", "pi", "ygap")

# parameter (Gali p52)
beta <- 0.99
sigma <- 1
phi <- 1 # Frisch Elasticity
alpha <- 1/3 # labor share
epsilon <- 6 # elasticity
theta <- 2/3 # stickiness
phi_pi <- 1.5
phi_y <- 0.5/4
rho_v <- 0.5

### Theta: epsilon big -> theta small -> MC is not reflected to the price
Theta <- (1-alpha)/(1-alpha+alpha*epsilon) # p47
### Lambda: overall sensitivity to MC; determined by Theta & theta(stickiness)
###         decreasing in (i) theta, alpha, and demand elasticity(eps)
lambda <- ((1-theta) * (1-beta*theta) / theta)*Theta # p47
kappa <- lambda * (sigma + (phi+alpha)/(1-alpha)) # p49
# kappa <- 0.5
```

```{r linear e, results='asis'}
# define A, B, E
B <- matrix(c(1, 0, 0,
              0, beta, 0,
              0, 1, sigma), nrow = 3, byrow = TRUE)
A <- matrix(c(rho_v, 0, 0,
              0, 1, -kappa,
              1, phi_pi, (sigma + phi_y)), nrow = 3, byrow = TRUE)
E <- matrix(c(0, 0, 0), nrow = 3, ncol = 1)

dimnames(B) <- dimnames(A) <- list(strs_var, strs_var)
dimnames(E) <- list(strs_var, "shock")

# print
my_print_matrix_latex(list(B = B, A = A, E = E))
```

#### Schur Decomposition

```{r schur e}
FF <- solve(B) %*% A # eig. value complex ...
# bk_e <- my_blanchard_kahn(A, B, E)
sch_e <- my_schur_decomp(A, B)
```

```{r solution e, results='asis'}
xt_code <- "v_{t}"
xt1_code <- "v_{t+1}"
yt_code <- "\\begin{bmatrix} \\pi_{t} \\\\ \\tilde{y}_{t} \\end{bmatrix}"

### yt -< xt, at
my_print_AxByCz_latex(yt_code, xt_code, B_mat = sch_e$sol_ytxt, round = 4)
### xt1 <- xt, at
my_print_AxByCz_latex(xt1_code, xt_code, B_mat =sch_e$sol_xt1xt, round = 4)
```


(memo: 状態変数がないからIRFが単純？)

```{r irf e}
irf_e <- my_schur_irf(sch_e, mat_init_xt = matrix(c(0.25), nrow = 1), TT = 12)

irf_e$irf %>% 
  mutate(pi = pi * 4) %>% # pi multiplied by 4
  pivot_longer(cols = -t, names_to = "Variable") %>% 
  ggplot() +
  geom_line(mapping = aes(x = t, y = value, color = Variable)) +
  geom_point(mapping = aes(x = t, y = value, color = Variable))
```

### (f). Redundant 4 Equations ver.

#### Linearized Form

$$
\begin{align}
  \mathbb{E}_t v_{t+1} &= \rho v_t + \epsilon^v_t \\[1em]
  \beta \mathbb{E}_t \pi_{t+1} &= \pi_t- \kappa \hat{y}_t \\[1em]
  \ \mathbb{E}_t \pi_{t+1}  + \sigma \mathbb{E}_t \hat{y}_{t+1} &= \sigma \hat{y}_t + \hat{i}_t \\[1em]
  0 &= v_t + \phi_{\pi}\pi_t + \phi_y\hat{y}_t - \hat{i}_t
\end{align}
$$

$$
\begin{align}
  y_{t} = \begin{bmatrix} \epsilon^v_t \\ \pi_{t}  \\ \tilde{y}_t \\ \hat{i}\end{bmatrix}, \quad
  B = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 
                      0 & \beta & 0 & 0 \\
                      0 & 1 & \sigma & 0 \\
                      0 & 0 & 0 & 0 \end{bmatrix}, \quad
  A = \begin{bmatrix} \rho_v & 0 & 0 & 0\\
                      0 & 1 & -\kappa & 0 \\
                      0 & 0 & \sigma & 1 \\
                      1 & \phi_{\pi} & \phi_{y} & -1 \end{bmatrix}, \quad
  E = \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0\end{bmatrix}.
\end{align}
$$

```{r linear f, results='asis'}
strs_var <- c("mpshock", "pi", "ygap", "i")

# define A, B, E
B <- matrix(c(1, 0, 0, 0,
              0, beta, 0, 0,
              0, 1, sigma, 0,
              rep(0, 4)), nrow = 4, byrow = TRUE)
A <- matrix(c(rho_v, 0, 0, 0,
              0, 1, -kappa, 0,
              0, 0, sigma, 1, 
              1, phi_pi, phi_y, -1), nrow = 4, byrow = TRUE)
E <- matrix(c(0, 0, 0, 0), nrow = 4)

dimnames(B) <- dimnames(A) <- list(strs_var, strs_var)
dimnames(E) <- list(strs_var, "shock")

# print
my_print_matrix_latex(list(B = B, A = A, E = E))
```

#### Schur Decomposition

```{r schur f}
sch_f <- my_schur_decomp(A, B)
```

```{r solution f, results='asis'}
xt_code <- "v_{t}"
xt1_code <- "v_{t+1}"
yt_code <- "\\begin{bmatrix} \\pi_{t} \\\\ \\tilde{y}_{t} \\\\ \\hat{i}_t \\end{bmatrix}"

### yt -< xt, at
my_print_AxByCz_latex(yt_code, xt_code, B_mat = sch_f$sol_ytxt, round = 4)
### xt1 <- xt, at
my_print_AxByCz_latex(xt1_code, xt_code, B_mat =sch_f$sol_xt1xt, round = 4)
```

```{r irf f}
irf_f <- my_schur_irf(sch_f, mat_init_xt = matrix(c(1), nrow = 1), TT = 12)

irf_f$irf <- irf_f$irf %>% 
    mutate(pi_e = (pi - kappa * ygap)/beta, # pp 49 eq. (21)
         ygap_e = ygap + 1/sigma * (i-pi_e), # pp 49 eq. (22) ; no rn change
         n = ygap/(1-alpha), # pp 46: no gap (tildey = y), no productivity change
         pi = pi * 4, 
         pi_e = pi_e * 4, 
         ) # pi multiplied by 4

irf_f$irf %>% head(5)

irf_f$irf %>% 
  pivot_longer(cols = -t, names_to = "Variable") %>% 
  ggplot() +
  geom_line(mapping = aes(x = t, y = value, color = Variable)) +
  geom_point(mapping = aes(x = t, y = value, color = Variable))
```

### (g). Technology Shock

#### Linearized Form

$$
\begin{align}
  \mathbb{E}_t v_{t+1} &= \rho v_t + \epsilon^v_t \\[1em]
  \mathbb{E}_t a_{t+1} &= \rho a_t + \epsilon^a_t \\[1em]
  \beta \mathbb{E}_t \pi_{t+1} &= \pi_t - \kappa \tilde{y}_t \\[1em]
  \mathbb{E}_t \pi_{t+1} + \sigma \mathbb{E}_t \tilde{y}_{t+1} &= \sigma \tilde{y}_t + \hat{i}_t - \hat{r}_t^n \\[1em]
  0 &= v_t + \phi_{\pi}\pi_t + \phi_y\hat{y}_t - \hat{i}_t\\[1em]
  0 &= - \sigma \psi_{ya}^n(1-\rho_a)a_t - \hat{r}_t^n
\end{align}
$$

$$
\begin{align}
  y_{t} = \begin{bmatrix} v_t \\ a_t \\ \pi_{t}  \\ \tilde{y}_t \\ \hat{i}_t \\ \hat{r}_t^n\end{bmatrix}, \quad
  B = \begin{bmatrix} 1 & 0 & 0 & 0 & 0 & 0 \\ 
                      0 & 1 & 0 & 0 & 0 & 0 \\ 
                      0 & 0 & \beta & 0 & 0 & 0 \\
                      0 & 0 & 1 & \sigma & 0 & 0 \\
                      0 & 0 & 0 & 0 & 0 & 0 \\
                      0 & 0 & 0 & 0 & 0 & 0 \end{bmatrix}, \quad
  A = \begin{bmatrix} \rho_v & 0 & 0 & 0 & 0 & 0 \\
                      0 & \rho_a & 0 & 0 & 0 & 0\\
                      0 & 0 & 1 & -\kappa & 0 & 0\\
                      0 & 0 & 0 & \sigma & 1 & -1\\
                      1 & 0 & \phi_{\pi} & \phi_{y} & -1 & 0 \\
                      0 & \sigma \psi_{ya}^n(1-\rho_a) & 0 & 0 & 0 & 1 \end{bmatrix}, \quad
  E = \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0\end{bmatrix}.
\end{align}
$$

```{r linear g, results='asis'}
strs_var <- c("mpshock", "prodshock", "pi", "ygap", "i", "rn")
rho_a <- 0.9
psi_ya_n <- (1+phi)/(sigma*(1-alpha)+phi+alpha)

# define A, B, E
B <- matrix(c(1, 0, 0, 0, 0, 0,
              0, 1, 0, 0, 0, 0,
              0, 0, beta, 0, 0, 0,
              0, 0, 1, sigma, 0, 0,
              rep(0, 6),
              rep(0, 6)), nrow = 6, byrow = TRUE)
A <- matrix(c(rho_v, 0, 0, 0, 0, 0,
              0, rho_a, 0, 0, 0, 0,
              0, 0,  1, -kappa, 0, 0,
              0, 0, 0, sigma, 1, -1,
              1, 0, phi_pi, phi_y, -1, 0,
              0, sigma*psi_ya_n*(1-rho_a), 0, 0, 0, 1), nrow = 6, byrow = TRUE)
E <- matrix(c(0, 0, 0, 0, 0, 0), nrow = 6)

dimnames(B) <- dimnames(A) <- list(strs_var, strs_var)
dimnames(E) <- list(strs_var, "shock")

# print
my_print_matrix_latex(list(B = B, A = A, E = E))
```

#### Schur Decomposition

```{r schur g}
sch_g <- my_schur_decomp(A, B)
```

```{r solution g, results='asis'}
xt_code <- "\\begin{bmatrix}  v_{t} \\\\ a_{t}  \\end{bmatrix}"
xt1_code <- "\\begin{bmatrix} v_{t+1} \\\\ a_{t+1}  \\end{bmatrix}"
yt_code <- "\\begin{bmatrix} \\pi_{t} \\\\ \\tilde{y}_{t} \\\\ \\hat{i}_t  \\\\ \\hat{t}_t^n \\end{bmatrix}"

### yt -< xt, at
my_print_AxByCz_latex(yt_code, xt_code, B_mat = sch_g$sol_ytxt, round = 4)
### xt1 <- xt, at
my_print_AxByCz_latex(xt1_code, xt_code, B_mat =sch_g$sol_xt1xt, round = 4)
```

```{r irf g}
irf_g <- my_schur_irf(sch_g, mat_init_xt = matrix(c(0, 1), nrow = 2), TT = 12)

irf_g$irf <- irf_g$irf %>% 
  mutate(
    pi = pi * 4
  ) # pi multiplied by 4

irf_g$irf %>% head(5)

irf_g$irf %>% 
  dplyr::select(-mpshock) %>% 
  pivot_longer(cols = -t, names_to = "Variable") %>% 
  ggplot() +
  geom_line(mapping = aes(x = t, y = value, color = Variable)) +
  geom_point(mapping = aes(x = t, y = value, color = Variable))
```

### (g2). Technology Shock

#### Linearized Form

$$
\begin{align}
  \mathbb{E}_t v_{t+1} &= \rho v_t + \epsilon^v_t \\[1em]
  \mathbb{E}_t a_{t+1} &= \rho a_t + \epsilon^a_t \\[1em]
  \mathbb{E}_t u_{t+1} &= \rho u_t + \epsilon^u_t \\[1em]
  \beta \mathbb{E}_t \pi_{t+1} + u_t &= \pi_t - \kappa \tilde{y}_t \\[1em]
  \mathbb{E}_t \pi_{t+1} + \sigma \mathbb{E}_t \tilde{y}_{t+1} &= \sigma \tilde{y}_t + \hat{i}_t - \hat{r}_t^n \\[1em]
  0 &= v_t + \phi_{\pi}\pi_t + \phi_y\hat{y}_t - \hat{i}_t\\[1em]
  0 &= - \sigma \psi_{ya}^n(1-\rho_a)a_t - \hat{r}_t^n
\end{align}
$$

$$
\begin{align}
  y_{t} = \begin{bmatrix} v_t \\ a_t \\ u_t \\ \pi_{t} \\ \tilde{y}_t \\ \hat{i}_t \\ \hat{r}_t^n\end{bmatrix}, \quad
  B = \begin{bmatrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 
                      0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 
                      0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 
                      0 & 0 & 0 & \beta & 0 & 0 & 0 \\
                      0 & 0 & 0 & 1 & \sigma & 0 & 0 \\
                      0 & 0 & 0 & 0 & 0 & 0 & 0 \\
                      0 & 0 & 0 & 0 & 0 & 0 & 0 \end{bmatrix}, \quad
  A = \begin{bmatrix} \rho_v & 0 & 0 & 0 & 0 & 0 & 0 \\
                      0 & \rho_a & 0 & 0 & 0 & 0 & 0 \\
                      0 & 0 & \rho_u & 0 & 0 & 0 & 0 \\ 
                      0 & 0 & -1 & 1 & -\kappa & 0 & 0 \\
                      0 & 0 & 0 & 0 & \sigma & 1 & -1 \\
                      1 & 0 & 0 & \phi_{\pi} & \phi_{y} & -1 & 0 \\
                      0 & \sigma \psi_{ya}^n(1-\rho_a) & 0 & 0 & 0 & 0 & 1 \end{bmatrix}, \quad
  E = \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0\end{bmatrix}.
\end{align}
$$

```{r linear g2, results='asis'}
strs_var <- c("mpshock", "prodshock", "costpushshock", "pi", "ygap", "i", "rn")
rho_a <- 0.9
rho_u <- 0.9
psi_ya_n <- (1+phi)/(sigma*(1-alpha)+phi+alpha)

# define A, B, E
B <- matrix(c(1, 0, 0, 0, 0, 0, 0,
              0, 1, 0, 0, 0, 0, 0,
              0, 0, 1, 0, 0, 0, 0,
              0, 0, 0, beta, 0, 0, 0,
              0, 0, 0, 1, sigma, 0, 0,
              rep(0, 7),
              rep(0, 7)), nrow = 7, byrow = TRUE)
A <- matrix(c(rho_v, 0, 0, 0, 0, 0, 0,
              0, rho_a, 0, 0, 0, 0, 0,
              0, 0, rho_u, 0, 0, 0, 0,
              0, 0,  -1, 1, -kappa, 0, 0,
              0, 0, 0, 0, sigma, 1, -1,
              1, 0, 0, phi_pi, phi_y, -1, 0,
              0, sigma*psi_ya_n*(1-rho_a), 0, 0, 0, 0, 1), nrow = 7, byrow = TRUE)
E <- matrix(c(0, 0, 0, 0, 0, 0, 0), nrow = 7)

dimnames(B) <- dimnames(A) <- list(strs_var, strs_var)
dimnames(E) <- list(strs_var, "shock")

# print
my_print_matrix_latex(list(B = B, A = A, E = E))
```

#### Schur Decomposition

```{r schur g2}
sch_g <- my_schur_decomp(A, B)
```

```{r solution g2, results='asis'}
xt_code <- "\\begin{bmatrix}  v_{t} \\\\ a_{t} \\\\ u_{t} \\end{bmatrix}"
xt1_code <- "\\begin{bmatrix} v_{t+1} \\\\ a_{t+1} \\\\ u_{t+1} \\end{bmatrix}"
yt_code <- "\\begin{bmatrix} \\pi_{t} \\\\ \\tilde{y}_{t} \\\\ \\hat{i}_t  \\\\ \\hat{t}_t^n \\end{bmatrix}"

### yt -< xt, at
my_print_AxByCz_latex(yt_code, xt_code, B_mat = sch_g$sol_ytxt, round = 4)
### xt1 <- xt, at
my_print_AxByCz_latex(xt1_code, xt_code, B_mat =sch_g$sol_xt1xt, round = 4)
```

```{r irf g2 tech}
irf_g2_tech <- my_schur_irf(sch_g, mat_init_xt = matrix(c(0, 1, 0), nrow = 3), TT = 12)

irf_g2_tech$irf <- irf_g2_tech$irf %>% 
  mutate(
    pi = pi * 4
  ) # pi multiplied by 4

irf_g2_tech$irf %>% head(5)

irf_g2_tech$irf %>% 
  dplyr::select(-mpshock) %>% 
  pivot_longer(cols = -t, names_to = "Variable") %>% 
  ggplot() +
  geom_line(mapping = aes(x = t, y = value, color = Variable)) +
  geom_point(mapping = aes(x = t, y = value, color = Variable))
```

```{r irf g2 cp}
irf_g2_cp <- my_schur_irf(sch_g, mat_init_xt = matrix(c(0, 0, 1), nrow = 3), TT = 12)

irf_g2_cp$irf <- irf_g2_cp$irf %>% 
  mutate(
    pi = pi * 4
  ) # pi multiplied by 4

irf_g2_cp$irf %>% head(5)

irf_g2_cp$irf %>% 
  dplyr::select(-mpshock) %>% 
  pivot_longer(cols = -t, names_to = "Variable") %>% 
  ggplot() +
  geom_line(mapping = aes(x = t, y = value, color = Variable)) +
  geom_point(mapping = aes(x = t, y = value, color = Variable))
```

```{r}
irf_g2_tech$irf %>% head(5)
irf_g2_cp$irf %>% head(5)
irf_g$irf
```

### (h). Price level

Finally, $\pi_t$ is split into $p_t$ and $p_{t-1}$. The following three equations are modified as follows:

$$
\begin{align}
  \beta \mathbb{E}_t \pi_{t+1} &= \pi_t - \kappa \tilde{y}_t \\[1em]
  \Leftrightarrow \beta(\mathbb{E}_t p_{t+1} -  p_t) &= (p_t - p_{t-1}) - \kappa \tilde{y}_t \\[1em]
  \Leftrightarrow \beta \mathbb{E}_t p_{t+1} &= (1 + \beta)p_t - p_{t-1} - \kappa \tilde{y}_t
\end{align}
$$



$$
\begin{align}
  \mathbb{E}_t \pi_{t+1} + \sigma \mathbb{E}_t \tilde{y}_{t+1} &= \sigma \tilde{y}_t + \hat{i}_t - \hat{r}_t^n \\[1em]
  (\mathbb{E}_t p_{t+1} - p_t) + \sigma \mathbb{E}_t \tilde{y}_{t+1} &= \sigma \tilde{y}_t + \hat{i}_t - \hat{r}_t^n \\[1em]
  \mathbb{E}_t p_{t+1}+ \sigma \mathbb{E}_t \tilde{y}_{t+1} &= p_t + \sigma \tilde{y}_t + \hat{i}_t - \hat{r}_t^n 
\end{align}
$$



$$
\begin{align}
  0 &= v_t + \phi_{\pi}\pi_t + \phi_y\hat{y}_t - \hat{i}_t\\[1em]
  0 &= v_t + \phi_{\pi}(p_t - p_{t-1}) + \phi_y\hat{y}_t - \hat{i}_t\\[1em]
  0 &= v_t + \phi_{\pi}p_t - \phi_{\pi}p_{t-1} + \phi_y\hat{y}_t - \hat{i}_t
\end{align}
$$

#### Linearized Form

$$
\begin{align}
  \mathbb{E}_t v_{t+1} &= \rho v_t + \epsilon^v_t \\[1em]
  \mathbb{E}_t a_{t+1} &= \rho a_t + \epsilon^a_t \\[1em]
  \beta \mathbb{E}_t p_{t+1}   &= (1 + \beta)p_t - p_{t-1} - \kappa \tilde{y}_t \\[1em]
  \mathbb{E}_t p_{t+1}+ \sigma \mathbb{E}_t \tilde{y}_{t+1} &= p_t + \sigma \tilde{y}_t + \hat{i}_t - \hat{r}_t^n \\[1em]
  0 &= v_t + \phi_{\pi}p_t - \phi_{\pi}p_{t-1} + \phi_y\hat{y}_t - \hat{i}_t\\[1em]
  0 &= - \sigma \psi_{ya}^n(1-\rho_a)a_t - \hat{r}_t^n\\[1em]
  p_t & = p_t
\end{align}
$$

$$
\begin{align}
  y_{t} = \begin{bmatrix} v_t \\ a_t \\ p_{t-1} \\ p_t \\ \tilde{y}_t \\ \hat{i}_t \\ \hat{r}_t^n\end{bmatrix}, \quad
  B = \begin{bmatrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 
                      0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 
                      0 & 0 & \beta & 0 & 0 & 0 & 0 \\
                      0 & 0 & 1 & 0 & \sigma & 0 & 0 \\
                      0 & 0 & 0 & 0 & 0 & 0 & 0 \\
                      0 & 0 & 0 & 0 & 0 & 0 & 0 \\
                      0 & 0 & 0 & 1 & 0 & 0 & 0 \end{bmatrix}, \quad
  A = \begin{bmatrix} \rho_v & 0 & 0 & 0 & 0 & 0 & 0 \\
                      0 & \rho_a & 0 & 0 & 0 & 0& 0 \\
                      0 & 0 & 1 + \beta& -1 &-\kappa & 0 & 0\\
                      0 & 0 & 1 & 0 & \sigma & 1 & -1\\
                      1 & 0 & \phi_{\pi} & -\phi_{\pi} & \phi_{y} & -1 & 0 \\
                      0 & \sigma \psi_{ya}^n(1-\rho_a) & 0 & 0 & 0 & 0 & 1 \\
                      0 & 0 & 1 & 0 & 0 & 0 & 0 \end{bmatrix}, \quad
  E = \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0\end{bmatrix}.
\end{align}
$$

```{r linear h, results='asis'}
strs_var <- c("mpshock", "prodshock", "ptm1", "pt", "ygap", "i", "rn")
rho_a <- 0.9
psi_ya_n <- (1+phi)/(sigma*(1-alpha)+phi+alpha)

# define A, B, E
B <- matrix(c(1, 0, 0, 0, 0, 0, 0, 
              0, 1, 0, 0, 0, 0, 0,
              0, 0, -beta, beta, 0, 0, 0,
              0, 0, -1, 1, sigma, 0, 0,
              rep(0, 7),
              rep(0, 7),
              0, 0, 1, 0, 0, 0, 0), nrow = 7, byrow = TRUE)
A <- matrix(c(rho_v, 0, 0, 0, 0, 0, 0,
              0, rho_a, 0, 0, 0, 0, 0,
              0, 0,  -1, 1, -kappa, 0, 0,
              0, 0, 0, 0, sigma, 1, -1,
              1, 0, -phi_pi, phi_pi, phi_y, -1, 0,
              0, sigma*psi_ya_n*(1-rho_a), 0, 0, 0, 0, 1,
              0, 0, 0, 1, 0, 0, 0), nrow = 7, byrow = TRUE)
E <- matrix(c(0, 0, 0, 0, 0, 0, 0), nrow = 7)

dimnames(B) <- dimnames(A) <- list(strs_var, strs_var)
dimnames(E) <- list(strs_var, "shock")

# print
my_print_matrix_latex(list(B = B, A = A, E = E))
```

#### Schur Decomposition

```{r schur h}
sch_h <- my_schur_decomp(A, B)
# bk_h <- my_blanchard_kahn(A, B, rho = 0)
```

```{r solution h, results='asis'}
xt_code <- "\\begin{bmatrix}  v_{t} \\\\ a_{t} \\\\ p_{t-1} \\end{bmatrix}"
xt1_code <- "\\begin{bmatrix} v_{t+1} \\\\ a_{t+1}  \\\\ p_{t}\\ end{bmatrix}"
yt_code <- "\\begin{bmatrix} p_{t} \\\\ \\tilde{y}_{t} \\\\ \\hat{i}_t \\\\ \\hat{t}_t^n \\end{bmatrix}"

### yt -< xt, at
my_print_AxByCz_latex(yt_code, xt_code, B_mat = sch_h$sol_ytxt, round = 4)
### xt1 <- xt, at
my_print_AxByCz_latex(xt1_code, xt_code, B_mat =sch_h$sol_xt1xt, round = 4)
```

```{r irf h}
irf_h <- my_schur_irf(sch_h, mat_init_xt = matrix(c(0, 1, 0), nrow = 3), TT = 12)

irf_h$irf <- irf_h$irf %>% 
  mutate(pt = pt * 4,
         ptm1 = ptm1 * 4,
         pi = pt - ptm1
  ) # pi multiplied by 4

irf_h$irf %>% head(5)

irf_h$irf %>% 
  pivot_longer(cols = -t, names_to = "Variable") %>% 
  ggplot() +
  geom_line(mapping = aes(x = t, y = value, color = Variable)) +
  geom_point(mapping = aes(x = t, y = value, color = Variable))
```

### (g). NK Gertler (TBA: last update: 26/2/11)

The following steps summarize the algebraic derivation of the impulse responses for the output gap ($\tilde{y}_t$) and inflation ($\pi_t$) in a basic New Keynesian model without endogenous state variables ($n=0$).

**Step 1. System Representation**

The structural equations (IS curve, NKPC, and Taylor Rule) are organized into the following matrix form:
$$B \mathbb{E}_t \mathbf{z}_{t+1} = A \mathbf{z}_t + E \mathbf{a}_t$$
where $\mathbf{z}_t = [\tilde{y}_t, \pi_t]^\top$ and $\mathbf{a}_t = [v_t, r_{t+1}^*]^\top$. The parameter matrices are defined as:
$$B = \begin{bmatrix} 1 & \sigma \\ 0 & \beta \end{bmatrix}, \quad A = \begin{bmatrix} 1 + \sigma \phi_y & \sigma \phi_\pi \\ -\lambda & 1 \end{bmatrix}, \quad E = \begin{bmatrix} \sigma & -\sigma \\ 0 & 0 \end{bmatrix}$$

**Step 2. Conversion to Canonical Form**

By multiplying by $B^{-1}$, we obtain the system in the form $\mathbb{E}_t \mathbf{z}_{t+1} = F \mathbf{z}_t + G \mathbf{a}_t$:
$$B^{-1} = \begin{bmatrix} 1 & -\sigma/\beta \\ 0 & 1/\beta \end{bmatrix}$$
$$F = B^{-1}A = \begin{bmatrix} (1 + \sigma \phi_y) + \frac{\sigma \lambda}{\beta} & \sigma (\phi_\pi - \frac{1}{\beta}) \\[1em] -\frac{\lambda}{\beta} & \frac{1}{\beta} \end{bmatrix}, \quad G = B^{-1}E = \begin{bmatrix} \sigma & -\sigma \\ 0 & 0 \end{bmatrix}$$

**Step 3. Solving the Non-predetermined Block**

Since there are no predetermined variables ($n=0$), a unique stable solution exists if all eigenvalues of $F$ lie outside the unit circle (the Taylor Principle). Under this condition, the solution is given by:
$$\mathbf{z}_t = - (F - \rho I)^{-1} G \mathbf{a}_t$$
Let $D = F - \rho I$. Its determinant is:
$$\det(D) = \frac{1}{\beta} \left[ (1 - \beta \rho_v)(1 + \sigma \phi_y - \rho_v) + \sigma \lambda (\phi_\pi - \rho_v) \right]$$

**Step 4. Explicit Impulse Responses (Impact Period)**

For a monetary policy shock $\epsilon_0^v = 1$ (where $\mathbf{a}_0 = [1, 0]^\top$), the initial impacts are:

**Output Gap Impact:**

$$\tilde{y}_0 = - \frac{\sigma(1 - \beta \rho_v)}{(1 - \beta \rho_v)(1 + \sigma \phi_y - \rho_v) + \sigma \lambda (\phi_\pi - \rho_v)}$$

**Inflation Impact:**

$$\pi_0 = - \frac{\sigma \lambda}{(1 - \beta \rho_v)(1 + \sigma \phi_y - \rho_v) + \sigma \lambda (\phi_\pi - \rho_v)}$$

**Step 5. Economic Verification**

The ratio of the responses satisfies the New Keynesian Phillips Curve relationship:
$$\frac{\pi_0}{\tilde{y}_0} = \frac{\lambda}{1 - \beta \rho_v}$$
This confirms that inflation is determined by the discounted sum of current and future output gaps. The presence of the term $(\phi_\pi - \rho_v)$ in the denominator demonstrates how a stronger policy response $\phi_\pi$ stabilizes the economy by reducing the magnitude of the impact.

```{r}
# Persistence of exogenous shocks
rho_v <- 0.5  # Monetary policy shock persistence
rho_r <- 0.9  # Natural rate shock persistence
rho_vec <- c(rho_v, rho_r) # Vector of persistences
```

```{r}
# Variables: ygap, pi
endo_names <- c("ygap", "pi")
shk_names <- c("v", "rn")

# B matrix: Coefficients for E_t[z_{t+1}]
B_endo <- matrix(c(1, sigma, 
                   0, beta), nrow = 2, byrow = TRUE)

# A matrix: Coefficients for z_t
A_endo <- matrix(c(1 + sigma * phi_y, sigma * phi_pi, 
                   -lambda_val,       1), nrow = 2, byrow = TRUE)

# E matrix: Impact of exogenous shocks on the system
E_shk <- matrix(c(sigma, -sigma, 
                  0,      0), nrow = 2, byrow = TRUE)

dimnames(B_endo) <- dimnames(A_endo) <- list(endo_names, endo_names)
colnames(E_shk) <- shk_names
```

```{r}
bk_2var <- my_blanchard_kahn(A_matrix = A_endo, 
                             B_matrix = B_endo, 
                             E_matrix = E_shk, 
                             rho = rho_vec) # Passing rho as a vector
```

```{r}
my_bk_irf(bk_2var)
```


## 4. Medium-scale DSGE Model

### Full Model

```{r param sw, eval = F, influde = F}
# === Household Preferences ===
beta     <- 0.9995       # 割引因子 cbeta in dynare
sigma_c  <- 1.5         # 消費の逆の相対的リスク回避度 csigma in dynare
h        <- 0.6361       # 習慣形成 chabb in dynare
phi      <- 1           # 労働供給弾力性（※設定値） ###
# === Technology ===
alpha <- 0.24 # capital share calfa in dynare
tau      <- 0.025       # ctou in Dynare
# === Investment adjustment cost ===
varphi   <- 6.0144      # 投資調整コストパラメータ # csadjcost in dynare
# === Price Setting ===
xi_p     <- 0.6        # Calvo価格設定確率 # cprobp
gamma_p  <- 0.47        # インフレの指数的慣性 # cindp in dynare
# === Wage Setting ===
xi_w     <- 0.8087        # Calvo賃金設定確率 # cprobw
gamma_w  <- 0.3243         # 名目賃金の指数的慣性 # cindw in dynare
# === Monetary Policy (Taylor Rule) ===
rho <- 0.8762        # crr in dynare
r_pi <- 1.488 #crpi in dynare
r_y <- 0.0593 # cry in dynare
rho_a <- rho_b <- rho_I <- rho_G <- rho_L <- 0.9
lambda_w <- 0.5 # Uhlig lect
sigma_L <- 2.4 # Uhlig lect

# steadystate
fc <- 1.5 # fixed cost share CFC in dynare

Rrbar <- 1/beta # cr in dynare
rkbar <- 1/beta + tau - 1 # crk in dynare
wbar <- (alpha^alpha*(1-alpha)^(1-alpha)/(fc*rkbar^alpha))^(1/(1-alpha)) # real wage; cw in dynare  
LKbar <- ((1-alpha)/alpha) * (rkbar/wbar)
KYbar <- fc * (LKbar)^(alpha-1)
GYbar <- 0.18 # cg in dynare
```

$$
\begin{aligned}
(1)\quad & \hat{K}_t = (1 - \tau) \hat{K}_{t-1} + \tau \hat{I}_{t-1} \\[1em]
(2)\quad & \hat{L}_t = -\hat{w}_t + (1 + \psi) \hat{r}^k_t + \hat{K}_{t-1} \\[1em]
(3)\quad & \hat{Y}_t = (1 - \tau_{ky} - g_y) \hat{C}_t + \tau_{ky} \hat{I}_t + \hat{\epsilon}^G_t \\[1em]
(4)\quad & \hat{Y}_t = \phi \hat{\epsilon}^a_t + \phi \alpha \hat{K}_{t-1} + \phi \alpha \psi \hat{r}^k_t + \phi (1 - \alpha) \hat{L}_t \\[1em]
(5)\quad & \hat{R}_t = \rho \hat{R}_{t-1} + (1 - \rho) \left\{ \bar{\pi}_t + r_{\pi} (\hat{\pi}_{t-1} - \bar{\pi}_t) + r_Y (\hat{Y}_t - \hat{Y}^P_t) \right\} \\
& \quad + r_{\Delta \pi} (\hat{\pi}_t - \hat{\pi}_{t-1}) + r_{\Delta Y} \left[ (\hat{Y}_t - \hat{Y}^P_t) - (\hat{Y}_{t-1} - \hat{Y}^P_{t-1}) \right] + \eta^R_t \\[1em]
(6)\quad & \hat{C}_t = \frac{h}{1 + h} \hat{C}_{t-1} + \frac{1}{1 + h} \mathbb{E}_t \hat{C}_{t+1} - \frac{1 - h}{(1 + h) \sigma_c} (\hat{R}_t - \mathbb{E}_t \hat{\pi}_{t+1}) + \frac{1 - h}{(1 + h) \sigma_c} \hat{\epsilon}^b_t \\[1em]
(7)\quad & \hat{I}_t = \frac{1}{1 + \beta} \hat{I}_{t-1} + \frac{\beta}{1 + \beta} \mathbb{E}_t \hat{I}_{t+1} + \frac{\varphi}{1 + \beta} \hat{Q}_t + \hat{\epsilon}^I_t \\[1em]
(8)\quad & \hat{Q}_t = - (\hat{R}_t - \mathbb{E}_t \hat{\pi}_{t+1}) + \frac{1 - \tau}{1 - \tau + r^k} \mathbb{E}_t \hat{Q}_{t+1} + \frac{r^k}{1 - \tau + r^k} \mathbb{E}_t \hat{r}^k_{t+1} + \eta^Q_t \\[1em]
(9)\quad & \hat{\pi}_t = \frac{\beta}{1 + \beta \gamma_p} \mathbb{E}_t \hat{\pi}_{t+1} + \frac{\gamma_p}{1 + \beta \gamma_p} \hat{\pi}_{t-1} \\
& \quad + \frac{1}{1 + \beta \gamma_p} \cdot \frac{(1 - \beta \xi_p)(1 - \xi_p)}{\xi_p} \left[ \alpha \hat{r}^k_t + (1 - \alpha) \hat{w}_t - \hat{\epsilon}^a_t \right] + \eta^p_t \\[1em]
(10)\quad & \hat{w}_t = \frac{\beta}{1 + \beta} \mathbb{E}_t \hat{w}_{t+1} + \frac{1}{1 + \beta} \hat{w}_{t-1} + \frac{\beta}{1 + \beta} \mathbb{E}_t \hat{\pi}_{t+1} - \frac{1 + \beta \gamma_w}{1 + \beta} \hat{\pi}_t \\
& \quad + \frac{\gamma_w}{1 + \beta} \hat{\pi}_{t-1} - \frac{1}{1 + \beta} \cdot \frac{(1 - \beta \xi_w)(1 - \xi_w)}{(1 + \frac{(1 + \lambda_w) \sigma_L}{\lambda_w}) \xi_w} \left[ \hat{w}_t - \sigma_L \hat{L}_t - \frac{\sigma_c}{1 - h} (\hat{C}_t - h \hat{C}_{t-1}) + \hat{\epsilon}^L_t \right] + \eta^w_t
\end{aligned}
$$

```{r param uhlig}
# === Household Preferences ===
beta     <- 0.99       # 割引因子 cbeta in dynare
tau      <- 0.025       # ctou in Dynare
alpha <- 0.3 # capital share calfa in dynare
psi   <- 1/0.169      # 投資調整コストパラメータ # csadjcost in dynare
gamma_p  <- 0.469        # インフレの指数的慣性 # cindp in dynare
gamma_w  <- 0.763         # 名目賃金の指数的慣性 # cindw in dynare
lambda_w <- 0.5 # Uhlig lect
xi_p     <- 0.908        # Calvo価格設定確率 # cprobp
xi_w     <- 0.737        # Calvo賃金設定確率 # cprobw
sigma_L <- 2.4 # Uhlig lect
sigma_c  <- 1.353         # 消費の逆の相対的リスク回避度 csigma in dynare
h        <- 0.573       # 習慣形成 chabb in dynare
phi      <- 1.408  # 1 + fc
varphi <- 1/6.771

rkbar <- 1/beta + tau - 1 # crk in dynare
invbar <- 0.22
Cbar <- 0.6
KYbar <- invbar/tau # 8.8
GYbar <- 1-Cbar-invbar

r_y <- 0.099 # cry in dynare
r_pi <- 1.684 #crpi in dynare
r_dy <- 0.159
r_dpi <- 0.14
  
rho <- 0.961        # crr in dynare
rho_a <- rho_b <- rho_I <- rho_G <- rho_L <- 0.9
```

```{r mat prep}
strs_y <- c(
  "eps_a", "eps_b", "eps_I", "eps_L", "eps_G", # shock process
  "K", "R", "Y", "Yp", "Yg", "C", "I", "pi", "w", "Q", "rk", "L", "Rr",
  "E_C", "E_I", "E_Q", "E_pi", "E_w", "E_rk"
  )
n_y <- length(strs_y)
strs_shk <- c(
  "eta_a", "eta_b", "eta_I", "eta_L", "eta_G", # shock process 1
  "eta_Q", "eta_pi", "eta_w" # shock process 2
)
n_shk <- length(strs_shk)
strs_eerr <- c("E_C", "E_I", "E_Q", "E_pi", "E_w", "E_rk")
n_eerr <- length(strs_eerr)
Gamma_0 <- Gamma_1 <- matrix(0, n_y, n_y) %>% `colnames<-`(strs_y)
Psi <- matrix(0, n_y, n_shk) %>% `colnames<-`(strs_shk)
Pi <- matrix(0, n_y, n_eerr) %>% `colnames<-`(strs_eerr)
```

```{r mat new}
# === 式(1): capital accumulation (===)
rnum <- 0
rnum <- rnum + 1
Gamma_0[rnum, "K"] <- 1
Gamma_1[rnum, c("K", "I")] <- c(1 - tau, tau)
# === 式(2): labor demand === psi; capital adjustment cost SW 34
rnum <- rnum + 1
Gamma_0[rnum, c("L", "w", "rk")] <- c(1, 1, -(1+psi))
Gamma_1[rnum, c("K")] <- 1
# === 式(3): demand identity === SW 35 tau
rnum <- rnum + 1
Gamma_0[rnum, c("Y", "C", "I", "eps_G")] <- c(-1, (1-tau*KYbar-GYbar) , (tau*KYbar), 1)
# === 式(4): production function ===  phi, alpha, psi SW 35
rnum <- rnum + 1
Gamma_0[rnum, c("Y", "eps_a", "rk",  "L")] <- c(-1, phi*c(1, alpha*psi, (1-alpha)))
Gamma_1[rnum, c("K")] <- -phi*alpha
# === 式(5): Taylor rule === ### SW 2007: pi -> modified to pi
rnum <- rnum + 1
Gamma_0[rnum, c("R", "pi", "Yg")] <- c(1, -(1-rho)*r_pi-r_dpi, -(1-rho)*r_y-r_dy)
Gamma_1[rnum, c("R", "pi", "Yg")] <- c(rho, -r_dpi, -r_dy)
Psi[rnum, "eta_pi"] <- 1
# === 式(6): Consumption Euler with habit formation ===
rnum <- rnum + 1
Gamma_0[rnum, c("C", "E_C", "R", "E_pi", "eps_b")] <- 
  c(1, -1/(1+h), (1-h)/((1+h)*sigma_c), -(1-h)/((1+h)*sigma_c), -(1-h)/((1+h)*sigma_c))
Gamma_1[rnum, c("C")] <- c(h/(1+h))
# === 式(7): Investment with Q-theory === 
rnum <- rnum + 1
Gamma_0[rnum, c("I", "Q", "E_I", "eps_I")] <- c(1, -varphi/(1+beta), -beta / (1 + beta), -1)
Gamma_1[rnum, c("I")] <- 1/(1+beta)
# === 式(8): Q equation (forward-looking) ===
rnum <- rnum + 1
Gamma_0[rnum, c("Q", "R", "E_pi", "E_Q", "E_rk")] <- 
  c(1, 1, -1, -(1-tau)/(1-tau+rkbar), -rkbar/(1-tau+rkbar))
Psi[rnum, "eta_Q"] <- 1
# === 式(9): NK Phillips Curve (gamma_p included) ===
rnum <- rnum + 1
mu_p <- ((1 - beta * xi_p) * (1 - xi_p)) / xi_p
denom_p <- 1 + beta * gamma_p
Gamma_0[rnum, c("pi", "E_pi", "rk", "w", "eps_a")] <-
  c(1, -beta/denom_p, -mu_p/denom_p*c(psi*alpha, 1-alpha, -1))
Gamma_1[rnum, "pi"] <-gamma_p/denom_p
Psi[rnum, "eta_pi"] <- 1
# === 式(10): Wage Phillips Curve (gamma_w, h included) ===
rnum <- rnum + 1
mu_w <- ((1-beta*xi_w)*(1 -xi_w))/(xi_w*(1+((1+lambda_w)*sigma_L)/lambda_w))
denom_w <- 1+beta
Gamma_0[rnum, c("w", "E_w", "pi", "E_pi")] <- 
  c(1, -beta/denom_w, (1+beta*gamma_w)/denom_w, -beta/denom_w)
Gamma_0[rnum, c("w", "L", "C", "eps_L")] <- Gamma_0[rnum, c("w", "L", "C", "eps_L")] + 
   mu_w/denom_w * c(1, -sigma_L, -sigma_c/(1-h), 1)
Gamma_1[rnum, c("w", "pi", "C")] <- c(1/denom_w, gamma_w/denom_w, mu_w/denom_w*sigma_c*(h/1-h))
Psi[rnum, "eta_w"] <- 1
# === 式(11): gap = act - pot
rnum <- rnum + 1
Gamma_0[rnum, c("Yg", "Y", "Yp")] <- c(-1, 1, -1)
# === 式(12): pot
rnum <- rnum + 1
Gamma_0[rnum, c("Yp", "Y")] <- c(1, -1)

rnum <- rnum + 1; Gamma_0[rnum, "eps_a"] <- Psi[rnum, "eta_a"] <- 1; Gamma_1[rnum, "eps_a"] <- rho_a;
rnum <- rnum + 1; Gamma_0[rnum, "eps_b"] <- Psi[rnum, "eta_b"] <- 1; Gamma_1[rnum, "eps_b"] <- rho_b;
rnum <- rnum + 1; Gamma_0[rnum, "eps_I"] <- Psi[rnum, "eta_I"] <- 1; Gamma_1[rnum, "eps_I"] <- rho_I;
rnum <- rnum + 1; Gamma_0[rnum, "eps_L"] <- Psi[rnum, "eta_L"] <- 1; Gamma_1[rnum, "eps_L"] <- rho_L;
rnum <- rnum + 1; Gamma_0[rnum, "eps_G"] <- Psi[rnum, "eta_G"] <- 1; Gamma_1[rnum, "eps_G"] <- rho_G;

rnum <- rnum + 1; Gamma_0[rnum, "C"] <- Gamma_1[rnum, "E_C"] <- Pi[rnum, "E_C"] <- 1
rnum <- rnum + 1; Gamma_0[rnum, "I"] <- Gamma_1[rnum, "E_I"] <- Pi[rnum, "E_I"] <- 1
rnum <- rnum + 1; Gamma_0[rnum, "Q"] <- Gamma_1[rnum, "E_Q"] <- Pi[rnum, "E_Q"] <- 1
rnum <- rnum + 1; Gamma_0[rnum, "pi"] <- Gamma_1[rnum, "E_pi"] <- Pi[rnum, "E_pi"] <- 1
rnum <- rnum + 1; Gamma_0[rnum, "w"] <- Gamma_1[rnum, "E_w"] <- Pi[rnum, "E_w"] <- 1
rnum <- rnum + 1; Gamma_0[rnum, "rk"] <- Gamma_1[rnum, "E_rk"] <- Pi[rnum, "E_rk"] <- 1

```

```{r, results='asis'}
my_print_matrix_latex(list("\\Gamma_0" = Gamma_0), round = 2)
my_print_matrix_latex(list("\\Gamma_1" = Gamma_1), round = 2)
my_print_matrix_latex(list("\\Psi" = Psi), round = 2)
my_print_matrix_latex(list("\\Pi" = Pi), round = 2)

str_var_latex_t <- strs_y %>% 
  sapply(function(x){
    xx <- ifelse(!is.na(str_match(x, "eps_")),
                 paste0(str_replace(x, "eps_", "\\\\varepsilon^{"), "}"),
                 x)
    ifelse(!is.na(str_match(xx, "^E_")),
           str_c(str_replace(xx, "E_", "\\\\mathbb{E}_{t}"),"_{t+1}"),
           str_c(xx, "_{t}"))})

str_var_latex_tm1 <- str_var_latex_t %>% 
  sapply(function(x){x %>% str_replace("\\{t\\}", "{t-1}") %>% str_replace("\\{t+1\\}", "{t}")})
  
  
for(r in (1:24)){
  print(r)
  A_all <- Gamma_0[r, ]
  B_all <- Gamma_1[r, ]
  idx_A_nonzero <- (A_all != 0)
  idx_B_nonzero <- (B_all != 0)
  A_nonzero <- Gamma_0[r, idx_A_nonzero, drop = F]
  B_nonzero <- Gamma_1[r, idx_B_nonzero, drop = F]
  x1_nonzero <- str_var_latex_t[idx_A_nonzero] %>% 
    str_c(collapse = " \\\\ ") %>% 
    str_c("\\begin{bmatrix}", ., "\\end{bmatrix}", sep = " ")
  x_nonzero <- str_var_latex_tm1[idx_B_nonzero] %>% 
    str_c(collapse = " \\\\ ") %>% 
    str_c("\\begin{bmatrix}", ., "\\end{bmatrix}", sep = " ")
  if(length(A_nonzero) == 0){A_nonzero = 0; x1_nonzero = ""}
  if(length(B_nonzero) == 0){B_nonzero = 0; x_nonzero = ""}
  my_print_AxByCz_latex(x1_nonzero, x_nonzero, A_mat = A_nonzero, B_mat = B_nonzero, round = 2)
}
```

$$
\begin{bmatrix}1 & -1 & 0.6 & 0.22\end{bmatrix} \begin{bmatrix} \epsilon^{G}_{t} \\ Y_{t} \\ C_{t} \\ I_{t} \end{bmatrix}
$$

```{r mat prep old, eval = F, influde = F}
# 変数名ベクトル（x_t）
strs_var <- c(
  # 9 shocks
  "eps_a", "eps_b", "eps_I", "eps_L", "eps_G", "eta_R", "eta_Q", "eta_p", "eta_w",
  # 8 predetermined
  "Km1", "Rm1", "Cm1", "Im1", "pim1", "wm1", "Ym1", "Rrm1",
  # 6 predetermined F
  "Km1_F", "Rm1_F", "Cm1_F", "Im1_F", "Rrm1_F", 
  "YGm1", "Ym1_F", "wm1_F",  
  "R", "C", "I", "pi", "w", "Y", "Rr",  
  "Q", "rk", "L",
  "R_F", "C_F", "I_F", "w_F", "Y_F", "Rr_F", "YG",
  "Q_F", "rk_F", "L_F"
  )
n_vars <- length(strs_var)   # 25
# A, B のゼロ初期化
A <- B <- matrix(0, n_vars, n_vars)
dimnames(A) <- dimnames(B) <- list(strs_var, strs_var)
# index ヘルパー関数
ixs <- function(names) sapply(names, function(name){(which(strs_var == name))})
```

```{r mat 1 old, eval = F, influde = F}
# shocks: 9
rnum <-  1; A[rnum, ixs("eps_a")] <- 1; B[rnum, ixs("eps_a")] <- rho_a
rnum <-  2; A[rnum, ixs("eps_b")] <- 1; B[rnum, ixs("eps_b")] <- rho_b
rnum <-  3; A[rnum, ixs("eps_I")] <- 1; B[rnum, ixs("eps_I")] <- rho_I
rnum <-  4; A[rnum, ixs("eps_G")] <- 1; B[rnum, ixs("eps_G")] <- rho_G
rnum <-  5; A[rnum, ixs("eps_L")] <- 1; B[rnum, ixs("eps_L")] <- rho_L
rnum <-  6; A[rnum, ixs("eta_R")] <- 1; B[rnum, ixs("eta_R")] <- 0
rnum <-  7; A[rnum, ixs("eta_Q")] <- 1; B[rnum, ixs("eta_Q")] <- 0
rnum <-  8; A[rnum, ixs("eta_p")] <- 1; B[rnum, ixs("eta_p")] <- 0
rnum <-  9; A[rnum, ixs("eta_w")] <- 1; B[rnum, ixs("eta_w")] <- 0
# auxiliary: 4
rnum <- rnum + 1; A[rnum, "Rm1"] <- 1;  B[rnum,  "R"] <- 1
rnum <- rnum + 1; A[rnum, "Cm1"] <- 1;  B[rnum,  "C"] <- 1
rnum <- rnum + 1; A[rnum, "Im1"] <- 1;  B[rnum,  "I"] <- 1
rnum <- rnum + 1; A[rnum,"pim1"] <- 1;  B[rnum, "pi"] <- 1
rnum <- rnum + 1; A[rnum, "wm1"] <- 1;  B[rnum,  "w"] <- 1
rnum <- rnum + 1; A[rnum, "Ym1"] <- 1;  B[rnum,  "Y"] <- 1
### frexible
rnum <- rnum + 1; A[rnum, "Rm1_F"] <- 1;  B[rnum,  "R_F"] <- 1
rnum <- rnum + 1; A[rnum, "Cm1_F"] <- 1;  B[rnum,  "C_F"] <- 1
rnum <- rnum + 1; A[rnum, "Im1_F"] <- 1;  B[rnum,  "I_F"] <- 1
rnum <- rnum + 1; A[rnum, "wm1_F"] <- 1;  B[rnum,  "w_F"] <- 1
rnum <- rnum + 1; A[rnum, "Ym1_F"] <- 1;  B[rnum,  "Y_F"] <- 1
# redundant (real rate)
rnum <- rnum + 1; B[rnum, ixs(c("R", "Rr"))] <- c(1, -1); A[rnum, "pi"] <- 1
rnum <- rnum + 1; B[rnum, ixs(c("Rm1", "Rrm1"))] <- c(1, -1); A[rnum, "pim1"] <- 1
rnum <- rnum + 1; B[rnum, ixs(c("R_F", "Rr_F"))] <- c(1, -1)
rnum <- rnum + 1; B[rnum, ixs(c("Rm1_F", "Rrm1_F"))] <- c(1, -1)
# gap
rnum <- rnum + 1; B[rnum, ixs(c("YG", "Y", "Y_F"))] <- c(-1, 1, -1) #Ygap 
rnum <- rnum + 1; B[rnum, ixs(c("YGm1", "Ym1", "Ym1_F"))] <- c(-1, 1, -1) # Ygap-1
```

```{r mat 2 old, eval = F, influde = F}
# === 式(1): capital accumulation (===)
rnum <- rnum + 1
A[rnum, ixs("Km1")] <- 1 # LHS: Kt
B[rnum, ixs(c("Km1", "Im1"))] <- c(1 - tau, tau)
# === 式(2): labor demand === psi; capital adjustment cost SW 34
rnum <- rnum + 1
B[rnum, ixs(c("L", "w", "rk", "Km1"))] <- c(-1, -1, 1+psi, 1)
# === 式(3): demand identity === SW 35 tau
rnum <- rnum + 1
B[rnum, ixs(c("Y", "C", "I", "eps_G"))] <- c(-1, 1 - tau*KYbar - GYbar , tau*KYbar, 1)
# === 式(4): production function ===  phi, alpha, psi SW 35
rnum <- rnum + 1
B[rnum, ixs(c("Y", "eps_a", "rk", "Km1", "L"))] <- c(-1, phi * c(1, alpha*psi, alpha, (1-alpha)))
# === 式(5): Taylor rule === ### SW 2007: pi -> modified to pi
rnum <- rnum + 1
B[rnum, ixs(c("R", "Rm1", "pi", "YG", "eta_R"))] <- c(-1, rho, (1-rho)*c(r_pi, r_y), 1)
B[rnum, ixs(c("YG", "YGm1", "pi", "pim1"))] <- B[rnum, ixs(c("YG", "YGm1", "pi", "pim1"))] + c(r_dy, -r_dy, r_dpi, -r_dpi)
# === 式(6): Consumption Euler with habit formation ===
rnum <- rnum + 1
A[rnum, ixs("C")] <- -1/(1+h) # LHS: EtCt+1
B[rnum, ixs(c("Cm1", "C", "Rr", "eps_b"))] <- c(h/(1+h), -1, -(1-h)/((1+h)*sigma_c), (1-h)/((1+h) *sigma_c))
# === 式(7): Investment with Q-theory === 
rnum <- rnum + 1
A[rnum, ixs("I")] <- -beta / (1 + beta)  # I in A = Et[I_{t+1}]
B[rnum, ixs(c("I", "Im1", "Q", "eps_I"))] <- c(-1, 1/(1+beta), varphi/(1+beta), 1)
# === 式(8): Q equation (forward-looking) ===
rnum <- rnum + 1
A[rnum, ixs(c("Q", "rk"))] <- c(-(1-tau)/(1-tau+rkbar), -rkbar/(1-tau+rkbar))
B[rnum, ixs(c("Q", "Rr", "eta_Q"))] <- c(-1, -1, 1) # B: Q_t, Rr_t, eta_Q
# === 式(9): NK Phillips Curve (gamma_p included) ===
rnum <- rnum + 1
mu_p <- ((1 - beta * xi_p) * (1 - xi_p)) / xi_p
denom_p <- 1 + beta * gamma_p
A[rnum, ixs("pi")] <- - beta/denom_p
B[rnum, ixs(c("pi", "pim1", "rk", "w", "eps_a", "eta_p"))] <-
  c(-1, gamma_p/denom_p, mu_p/denom_p*c(psi*alpha, 1-alpha, -1), 1)
# === 式(10): Wage Phillips Curve (gamma_w, h included) ===
rnum <- rnum + 1
mu_w <- ((1-beta*xi_w)*(1 -xi_w))/(xi_w*(1+((1+lambda_w)*sigma_L)/lambda_w))
denom_w <- 1+beta
A[rnum, ixs(c("w", "pi"))] <- c(-beta/denom_w, -beta/denom_w)
B[rnum, ixs(c("w", "wm1", "pi", "pim1", "L", "C", "Cm1", "eps_L", "eta_w"))] <- c(
  -1 - mu_w/denom_w, 1/denom_w, -(1+beta*gamma_w)/denom_w, gamma_w/denom_w, # pi_t-1
  -(mu_w/denom_w)*c(-sigma_L, -(sigma_c)/(1-h), -sigma_c*(-h)/(1-h)), # c_t-1
  -mu_w/denom_w, 1 # eta
)

# === 式(1): capital accumulation (===)
rnum <- rnum + 1
A[rnum, ixs("Km1_F")] <- 1 # LHS: Kt
B[rnum, ixs(c("Km1_F", "Im1_F"))] <- c(1 - tau, tau)
# === 式(2): labor demand === psi; capital adjustment cost SW 34
rnum <- rnum + 1
B[rnum, ixs(c("L_F", "w_F", "rk_F", "Km1_F"))] <- c(-1, -1, 1+psi, 1)
# === 式(3): demand identity === SW 35 tau
rnum <- rnum + 1
B[rnum, ixs(c("Y_F", "C_F", "I_F", "eps_G"))] <- c(-1, 1 - tau*KYbar - GYbar , tau*KYbar, 1)
# === 式(4): production function ===  phi, alpha, psi SW 35
rnum <- rnum + 1
B[rnum, ixs(c("Y_F", "eps_a", "rk_F", "Km1_F", "L_F"))] <- c(-1, phi * c(1, alpha*psi, alpha, (1-alpha)))
# === 式(5): Taylor rule === ### no Y GAP
rnum <- rnum + 1
B[rnum, ixs(c("R_F", "Rm1_F", "eta_R"))] <- c(-1, rho, 1)
# === 式(6): Consumption Euler with habit formation ===
rnum <- rnum + 1
A[rnum, ixs("C_F")] <- -1/(1+h) # LHS: EtCt+1
B[rnum, ixs(c("Cm1_F", "C_F", "Rr_F", "eps_b"))] <- c(h/(1+h), -1, -(1-h)/((1+h)*sigma_c), (1-h)/((1+h) *sigma_c))
# === 式(7): Investment with Q-theory === 
rnum <- rnum + 1
A[rnum, ixs("I_F")] <- -beta / (1 + beta)  # I in A = Et[I_{t+1}]
B[rnum, ixs(c("I_F", "Im1_F", "Q_F", "eps_I"))] <- c(-1, 1/(1+beta), varphi/(1+beta), 1)
# === 式(8): Q equation (forward-looking) ===
rnum <- rnum + 1
A[rnum, ixs(c("Q_F", "rk_F"))] <- c(-(1-tau)/(1-tau+rkbar), -rkbar/(1-tau+rkbar))
B[rnum, ixs(c("Q_F", "Rr_F", "eta_Q"))] <- c(-1, -1, 1) # B: Q_t, Rr_t, eta_Q
# === 式(10): Wage Phillips Curve (gamma_w, h included) ===
rnum <- rnum + 1
B[rnum, ixs(c("w_F", "L_F", "C_F", "Cm1_F"))] <- c(
  -1, c(sigma_L, (sigma_c)/(1-h), sigma_c*(-h)/(1-h)))
```

```{r print old, results = "asis", eval = F, influde = F}
str_var_latex_t <- strs_var %>% 
  str_replace("_", "^") %>% 
  sapply(function(x){ifelse(!is.na(str_match(x, "m1$")),
                            str_replace(x, "m1$", "_{t-1}"),
                            str_c(x, "_{t}"))})

str_var_latex_t1 <- strs_var %>% 
  str_replace("_", "^") %>% 
  sapply(function(x){ifelse(!is.na(str_match(x, "m1$")),
                            str_replace(x, "m1$", "_{t}"),
                            str_c("\\mathbb{E} ", x, "_{t+1}"))})

for(r in (1:n_vars)){
  print(r)
  A_all <- A[r, ]
  B_all <- B[r, ]
  idx_A_nonzero <- (A_all != 0)
  idx_B_nonzero <- (B_all != 0)
  A_nonzero <- A[r, idx_A_nonzero, drop = F]
  B_nonzero <- B[r, idx_B_nonzero, drop = F]
  x1_nonzero <- str_var_latex_t1[idx_A_nonzero] %>% 
    str_c(collapse = " \\\\ ") %>% 
    str_c("\\begin{bmatrix}", ., "\\end{bmatrix}", sep = " ")
  x_nonzero <- str_var_latex_t[idx_B_nonzero] %>% 
    str_c(collapse = " \\\\ ") %>% 
    str_c("\\begin{bmatrix}", ., "\\end{bmatrix}", sep = " ")
  if(length(A_nonzero) == 0){A_nonzero = 0; x1_nonzero = ""}
  if(length(B_nonzero) == 0){B_nonzero = 0; x_nonzero = ""}
  my_print_AxByCz_latex(x1_nonzero, x_nonzero, A_mat = A_nonzero, B_mat = B_nonzero, round = 2)
}
```

```{r old, eval = F, include = F}
sch_dsge <- my_schur_decomp(B, A)
sch_dsge$sol_xt1xt %>% round(2)

irf_dsge <- my_schur_irf(sch_dsge, matrix(c(1, rep(0, 21)), nrow = 22), TT = 100)
# irf_dsge$irf %>% round(4) %>% my_checkascsv()
irf_dsge$irf %>%
  pivot_longer(cols = -t) %>% 
  mutate(var = str_remove(name, "_F$"),
         state = if_else(name == var, "baseline", "flexible")) %>% 
  filter(!grepl("eps_", var), !grepl("eta_", var), !grepl("m1", var)) %>% 
  filter(var %in% c("L", "K")) %>% 
  ggplot(mapping = aes(x = t, y = value, color = var))+
  geom_line(mapping = aes(linetype = state))

```



