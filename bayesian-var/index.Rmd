---
title: "Bayesian VARs"
author: "Kotaro Suita"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    number_sections: FALSE
    code_folding: show
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

<!-- The chunks in this code are classified as follows: -->

<!-- -   SET: Load package, set default options, define functions and variables, etc. -->

<!-- -   IMP: Import data. -->

<!-- -   PRE: Process data, including creating and editing variables, -->

<!-- -   FLT: Process data that involve FILTERING. -->

<!-- -   EDA: Exploratory Data Analysis -->

<!-- -   REG: Regressions -->

<!-- -   EXP: Export results -->

# Settings

The chapter contains some chunks that conduct document settings.

-   This chunk **removes all the variables** in the environment.

```{r SET housekeeping, class.source='fold-hide'}
rm(list = ls(all = TRUE))
```

-   This chunk **sets** `knitr` **options**.

```{r SET knit options, class.source='fold-hide'}
knitr::opts_chunk$set(
  block.title=T, # default: F / normally F
  fig.align = "center",
  results = "hold",
  fig.show = "hold",
  message = F, # when hiding messages
  warning = F  # when hiding errors
)
knitr::opts_hooks$set(label = function(options) {
  options$before = paste0('<div>Chunk: ', options$label, '</div>')
  return(options)
})
```

-   This chunk **loads the required packages** and **my functions**.

```{r SET libraries, class.source='fold-hide'}
pkgList <- c(
  "tidyverse", #must-have
  "matrixcalc", # for vec
  "vars", # for VAR
  "zoo", # table for VAR
  "modelsummary", # summary functions and reg. tables
  "quantmod" # FRED
)
easypackages::libraries(pkgList)
conflicted::conflict_prefer("lag", "dplyr")
conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter", "dplyr")
conflicted::conflict_prefer("complete", "dplyr")
rm(pkgList)

# source("C:/Users/kotaro/Desktop/R/common/myfuns.R")
```

-   This chunk sets **the seed**.

```{r SET seeds, class.source='fold-hide'}
set.seed(1111)
```

# Data

## Import and Pre-process

The data has 158 rows of observations and 25 columns. The variables are transformed as 2 labels (`#`, `Country`), 1 factor (`Club`) and 22 continuous variables.

```{r IMP dataset}
# 1) FREDから取得 → 四半期整合 → tibble化
getSymbols(c("GDPC1", "GDPDEF", "FEDFUNDS"), src = "FRED")

# RGDP, Deflator（四半期）: yearqtr index
rgdp_q <- zoo(as.numeric(GDPC1), as.yearqtr(index(GDPC1)))
def_q  <- zoo(as.numeric(GDPDEF), as.yearqtr(index(GDPDEF)))

# FF（月次）→ 四半期平均: yearqtr index
ff_m <- zoo(as.numeric(FEDFUNDS), as.yearmon(index(FEDFUNDS)))
ff_q <- aggregate(ff_m, as.yearqtr, mean)

# yearqtrで結合
z_q <- na.omit(merge(rgdp_q, def_q, ff_q))
colnames(z_q) <- c("RGDP", "DEF", "FF")

if (NROW(z_q) == 0) stop("Merged dataset is empty. Check series availability / overlap.")

# tibble: date は四半期末日（推計時に扱いやすい）
df_var <- tibble(
  date  = as.Date(as.yearqtr(index(z_q)), frac = 1),  # quarter end date
  lRGDP = 4*log(as.numeric(z_q[, "RGDP"])),
  lDEF  = 4*log(as.numeric(z_q[, "DEF"])),
  FF    = as.numeric(z_q[, "FF"])
)

print(dplyr::glimpse(df_var))
print(head(df_var))

# 2) 推計直前にだけ ts へ変換する関数
to_ts_quarterly <- function(df, cols = c("lRGDP", "lDEF", "FF")) {
  stopifnot(all(c("date", cols) %in% names(df)))
  df <- df %>% arrange(date)

  # date -> yearqtr
  q <- as.yearqtr(df$date)

  # 開始四半期
  y0 <- as.integer(floor(as.numeric(q[1])))
  qtr0 <- as.integer(round((as.numeric(q[1]) - y0) * 4 + 1))

  ts_out <- ts(as.matrix(df[, cols]), start = c(y0, qtr0), frequency = 4)
  colnames(ts_out) <- cols
  ts_out
}
```

```{r}
df_var
```

# Estimation

## OLS

```{r}
p <- 12

ts_var <- to_ts_quarterly(df_var)
var_est <- VAR(ts_var, p = p, type = "const")
coef_order <- c(
  unlist(lapply(1:p, function(l) paste0("lRGDP.l", l))),
  unlist(lapply(1:p, function(l) paste0("lDEF.l",  l))),
  unlist(lapply(1:p, function(l) paste0("FF.l",    l))),
  "const"
)
```

Quick check of result;

```{r}
msummary(var_est$varresult, stars = T, coef_map = coef_order, fmt = 3, statistic = "std.error",
         title = "Reduced-form VAR Estimation Results")

# stationary check
print("Roots")
roots(var_est)
```

## Bayesian

```{r}
M <- 3 # num of vars
p <- p # num of lags
K <- 1+M*p # num of total endos
TT <- NROW(df_var)-p

Y <- df_var[(p+1):NROW(df_var),2:4] %>% as.matrix() # T * M
y <- vec(Y)

make_lagged_X <- function(df, vars, p, add_const = TRUE) {
  stopifnot(p >= 1)
  stopifnot(all(vars %in% colnames(df)))

  T_df <- NROW(df)

  # ラグ行列
  X_list <- lapply(1:p, function(lag) {
    tmp <- df[(p + 1 - lag):(T_df - lag), vars, drop = FALSE]
    colnames(tmp) <- paste0(vars, ".l", lag)
    tmp
  })

  X <- dplyr::bind_cols(X_list)

  if (add_const) {
    const <- rep(1, nrow(X))
    X <- dplyr::bind_cols(const = const, X) %>% as.matrix()
  }

  return(X)
}

X <- make_lagged_X(df_var, c("lRGDP", "lDEF", "FF"), p = 12)

I_M <- diag(M)

A_OLS <- solve(t(X) %*% X) %*% t(X) %*% Y
X_big <- kronecker(I_M, X)
alpha_OLS <- solve(t(X_big) %*% X_big) %*% t(X_big) %*% y
vec(A_OLS)
alpha_OLS
round(vec(A_OLS)-alpha_OLS)

```

### Minnesota Prior

#### Known variance

$$
\Sigma = \hat{\Sigma}
$$

```{r}
Omega_Mn <- summary(var_est)$covres
as_tibble(Omega_Mn, rownames = " ")
```

#### Prior on coefficients

Koop and Korobilis 2.8式

$$
\alpha|\Sigma \sim N(\underline{\alpha}_{Mn}, \underline{V}_{Mn}), 
$$

```{r}
### hyperparamter
a1 <- 1
a2 <- 0.5
a3 <- 0.1

### alpha
alpha_Mn <- matrix(0, M*K, 1)
alpha_Mn[c(0*K+1+1, 1*K+2+1, 2*K+3+1)] <- 1

cbind(alpha_OLS, alpha_Mn) %>% round(2)

### V
V_Mn_diag <- rep(NA, M*K)

# lag decay part
V_Mn_r <- c(1, rep((1:p)^(-2), each = M)) 
# a and sigma part
for (i in 1:M) {
  V_Mn_asigma <- rep(NA_real_, K)
  
  V_Mn_asigma[1] <- a3 * Omega_Mn[i,i] # constant

  for (j in 1:M) {
    idx_j <- 1 + j + (0:(p-1)) * M # positions of variable j
    if (i == j) {
      V_Mn_asigma[idx_j] <- a1
    } else {
      V_Mn_asigma[idx_j] <- a2 * Omega_Mn[i,i] / Omega_Mn[j,j]
    }
  }
  V_Mn_diag[(1 + (i-1)*K):(i*K)] <- V_Mn_r * V_Mn_asigma
  
}

V_Mn <- diag(V_Mn_diag)
```

```{r}
V_Mn_post <- solve(solve(V_Mn)+kronecker(solve(Omega_Mn), t(X) %*% X))
alpha_Mn_post <- V_Mn_post %*% (solve(V_Mn) %*% alpha_Mn + kronecker(solve(Omega_Mn), t(X)) %*% y)
cbind(alpha_OLS, alpha_Mn, alpha_Mn_post) %>% round(2)
```

```{r}
A_OLS
A_Mn_post <- matrix(as.vector(alpha_Mn_post), nrow = K, ncol = M, byrow = F)

eq_names <- colnames(A_OLS)
if (is.null(eq_names)) eq_names <- paste0("eq", 1:M)

# ---- 1) OLSとPosteriorを縦持ちにする ----
df_ols <- as.data.frame(A_OLS) |>
  mutate(term = rownames(A_OLS)) |>
  pivot_longer(-term, names_to = "eq", values_to = "coef") |>
  mutate(method = "OLS")

df_post <- as.data.frame(A_Mn_post)
colnames(df_post) <- eq_names
df_post <- df_post |>
  mutate(term = rownames(A_OLS)) |>
  pivot_longer(-term, names_to = "eq", values_to = "coef") |>
  mutate(method = "Posterior")

df <- bind_rows(df_ols, df_post) |>
  # 定数は除外（ラグ軸に載らないので）
  filter(term != "const") |>
  # term から「説明変数」と「ラグ」を抽出（例: lRGDP.l3 -> var=lRGDP, lag=3）
  mutate(
    var = str_replace(term, "\\.l\\d+$", ""),
    lag = as.integer(str_extract(term, "(?<=\\.l)\\d+"))
  )

# ---- 2) 3変数×3方程式（=9パネル）に絞る（必要なら）----
# ここで var の順序を指定して見やすくする
var_levels <- c("lRGDP", "lDEF", "FF")
df <- df %>%
  mutate(
    var = factor(var, levels = var_levels),
    method = factor(method, levels = c("OLS", "Posterior"))
  )

# 方程式ごとにプロットを作って表示（3パネル：説明変数）
plots <- lapply(levels(factor(df$eq)), function(eq_i) {

  dfi <- df %>% filter(eq == eq_i)

  ggplot(dfi, aes(x = lag, y = coef, linetype = method, shape = method, group = method)) +
    geom_hline(yintercept = 0) +
    geom_line() +
    geom_point(size = 1.6) +
    scale_x_continuous(breaks = sort(unique(dfi$lag))) +
    facet_wrap(~ var, nrow = 3, scales = "free_y") +
    labs(
      x = "Lag",
      y = "Coefficient",
      linetype = "",
      shape = "",
      title = paste0("Equation: ", eq_i, " — OLS vs Minnesota Posterior"),
      subtitle = "Panels (free y-scale): regressors lRGDP, lDEF, FF"
    ) +
    theme_bw()
})

# すべて表示
for (g in plots) print(g)
```


https://www.r-econometrics.com/timeseries/bvar/   

T: 73 samples: 76 terms (1960Q1-1978Q4) - 2 lags - 1 dlog
p: 2 lags
k: 3 vars (invest, income, cons)


<!-- ```{r setup} -->
<!-- library(bvartools) -->
<!-- data("e1") -->
<!-- e1 <- diff(log(e1)) # Calculate first-log-differences -->
<!-- e1 <- window(e1, end = c(1978, 4)) # Reduce nobs -->
<!-- e1 <- e1 * 100 # Rescale data -->
<!-- plot(e1) # Plot the series -->
<!-- data <- gen_var(e1, p = 2, deterministic = "const") -->
<!-- ``` -->


<!-- $$ -->
<!-- \text{Let }Y = ( 3 \times 73)\text{, } X = (7 \times 73).\\ -->
<!-- A_{freq} = YX^{'}(XX^{'})^{-1}. -->
<!-- $$ -->

<!-- $$ -->
<!-- \text{Let }Y^* = ( 1 \times 219)\text{, } X^* = I_M \otimes X.\\ -->
<!-- vec(A_{freq}) = vec(Y){vec(X)}^{'}[vec(X){vec(X)}^{'}]^{-1}, where\\ -->
<!-- $$ -->

<!-- ```{r ols} -->
<!-- ### A -->
<!-- y <- t(data$data$Y) # K * T = 3 * 73 -->
<!-- x <- t(data$data$Z) # (K*p)+1 * T = 7 * 73 -->
<!-- A_freq <- tcrossprod(y, x) %*% solve(tcrossprod(x)) # K * (K*p)+1 = 3 * 7 -->
<!-- A_freq_mine <-  solve(x %*% t(x)) %*% (x %*% t(y)) # K * (K*p)+1 = 3 * 7 -->

<!-- ### A (vec expression) chatGPT -->
<!-- my_vec <- function(mat){ret <- matrix(mat)} -->
<!-- y_vec <- t(my_vec(y)) #  1 * (T*K) = 1 * 219 -->
<!-- x_vec <- kronecker(x, diag(1,3)) # {K * K} kron {(K*p)+1 * T} = 219 * 21 -->
<!-- A_freq_vec <- (y_vec %*% t(x_vec))  %*% solve(x_vec %*% t(x_vec)) # 1 * 21 -->
<!-- # y_vec_mine <- my_vec(t(y)) # (T*K) * 1 = 219 * 1 -->
<!-- # x_vec_mine <- kronecker(diag(1,3),t(x)) # {K * K} kron {(K*p)+1 * T} = 21 * 219 -->
<!-- # A_freq_vec_mine <- solve(t(x_vec) %*% x_vec) %*% (t(x_vec) %*% y_vec) # 21 * 1 -->


<!-- ### U -->
<!-- u_freq <- y - A_freq %*% x # K * T = 3 * 73 -->
<!-- u_sigma_freq <- tcrossprod(u_freq) / (ncol(y) - nrow(x)) # K * K = 3 * 3 -->

<!-- # Reset random number generator for reproducibility -->
<!-- set.seed(1234567) -->

<!-- iter <- 30000 # Number of iterations of the Gibbs sampler -->
<!-- burnin <- 15000 # Number of burn-in draws -->
<!-- store <- iter - burnin -->

<!-- tt <- ncol(y) # Number of observations -->
<!-- k <- nrow(y) # Number of endogenous variables -->
<!-- m <- k * nrow(x) # Number of estimated coefficients -->
<!-- ``` -->

<!-- ```{r bayesian setup} -->
<!-- # Reset random number generator for reproducibility -->
<!-- set.seed(1234567) -->

<!-- iter <- 30000 # Number of iterations of the Gibbs sampler -->
<!-- burnin <- 15000 # Number of burn-in draws -->
<!-- store <- iter - burnin -->

<!-- tt <- ncol(y) # Number of observations -->
<!-- k <- nrow(y) # Number of endogenous variables -->
<!-- m <- k * nrow(x) # Number of estimated coefficients -->
<!-- ``` -->

<!-- ```{r bayesian prior} -->
<!-- a_mu_prior <- matrix(0, m) # Vector of prior parameter means -->
<!-- a_v_i_prior <- diag(1, m) # Inverse of the prior covariance matrix -->

<!-- u_sigma_df_prior <- 6 # Prior degrees of freedom -->
<!-- u_sigma_scale_prior <- diag(1, k) # Prior covariance matrix -->
<!-- u_sigma_df_post <- tt + u_sigma_df_prior # Posterior degrees of freedom -->

<!-- ``` -->

<!-- ```{r Gibbs} -->
<!-- # Data containers for posterior draws -->
<!-- # str_lab <- expand.grid(v2 = colnames(A_freq), v1 = rownames(A_freq)) %>%  -->
<!-- #   with(., paste(v1, v2, sep = "_")) -->
<!-- str_y <- rownames(A_freq) -->
<!-- str_x <- colnames(A_freq) -->
<!-- str_lab <- outer(str_y, str_x, paste, sep = "_") %>%  -->
<!--   as.vector() -->
<!-- draws_a <- matrix(NA, m, store) %>%  -->
<!--     `rownames<-`(str_lab) -->
<!-- draws_a_mine <- matrix(NA, m, store) %>%  -->
<!--   `rownames<-`(str_lab) -->

<!-- draws_sigma <- matrix(NA, k * k, store) -->

<!-- # Initial values -->
<!-- u_sigma_i <- solve(u_sigma_freq) -->

<!-- # Start Gibbs sampler -->
<!-- for (draw in 1:iter) { -->
<!--   # Draw conditional mean parameters -->
<!--   a <- post_normal(y, x, u_sigma_i, a_mu_prior, a_v_i_prior) -->
<!--   ### Mumtaz p.34 matlab code -->
<!--   v_mine <- solve(a_v_i_prior + kronecker(u_sigma_i,x %*% t(x))) -->
<!--   m_mine <- v_mine %*% (a_v_i_prior %*% a_mu_prior + kronecker(u_sigma_i,x %*% t(x)) %*% t(A_freq_vec)) -->
<!--   a_mine <- MASS::mvrnorm(1, m_mine, v_mine) %>% as.matrix() -->

<!--   # Draw variance-covariance matrix -->
<!--   u <- y - matrix(a, k) %*% x # Obtain residuals -->
<!--   u_sigma_scale_post <- solve(u_sigma_scale_prior + tcrossprod(u)) -->
<!--   u_sigma_i <- matrix(rWishart(1, u_sigma_df_post, u_sigma_scale_post)[,, 1], k) -->
<!--   u_sigma <- solve(u_sigma_i) # Invert Sigma_i to obtain Sigma -->

<!--   # Store draws -->
<!--   if (draw > burnin) { -->
<!--     draws_a[, draw - burnin] <- a -->
<!--     draws_a_mine[, draw - burnin] <- a_mine -->
<!--     draws_sigma[, draw - burnin] <- u_sigma -->
<!--   } -->
<!-- } -->

<!-- ``` -->


<!-- ```{r Gibbs} -->
<!-- ### outputs -->

<!-- tbl_A_bayes <- rbind( -->
<!--   mutate(t(draws_a) %>% as_tibble(), algo = "package"), -->
<!--   mutate(t(draws_a_mine) %>% as_tibble(), algo = "mine") -->
<!-- ) -->

<!-- tbl_A_freq <- tibble(name = str_lab, value = my_vec(A_freq) %>% as.numeric()) %>%  -->
<!--   transmute(y = str_remove(name, "_.*$") %>% factor(levels = str_y),  -->
<!--             x = str_remove(name, "^.*_") %>% factor(levels = str_x), -->
<!--             value) -->

<!-- tbl_A_bayes_dens <- tbl_A_bayes %>%  -->
<!--   pivot_longer(cols = -algo) %>%  -->
<!--   transmute(algo,  -->
<!--             y = str_remove(name, "_.*$") %>% factor(levels = str_y),  -->
<!--             x = str_remove(name, "^.*_") %>% factor(levels = str_x), -->
<!--             value) -->

<!-- tbl_A_bayes_ci <- tbl_A_bayes_dens %>%  -->
<!--   group_by(algo, y, x) %>%  -->
<!--   summarize(ltile = quantile(value, 0.05), -->
<!--             median = quantile(value, 0.50), -->
<!--             utile = quantile(value, 0.95)) %>%  -->
<!--   ungroup() -->


<!-- ggplot() + -->
<!--   geom_density(data = tbl_A_bayes_dens, -->
<!--                mapping = aes(x = value, color = algo)) + -->
<!--   facet_wrap(~ x + y, ncol = 3,scales = "free")+ -->
<!--   # geom_point(data = tbl_A_freq, mapping = aes(x = value, y = 0))+ -->
<!--   geom_vline(data = tbl_A_freq, aes(xintercept = value))+ -->
<!--   geom_point(data = tbl_A_bayes_ci %>% filter(algo == "package"), -->
<!--              mapping = aes(x = ltile, y = 0))+ -->
<!--   geom_point(data = tbl_A_bayes_ci %>% filter(algo == "package"), -->
<!--              mapping = aes(x = utile, y = 0))+ -->
<!--   geom_point(data = tbl_A_bayes_ci %>% filter(algo == "package"), -->
<!--              mapping = aes(x = median, y = 0)) -->


<!-- ``` -->


