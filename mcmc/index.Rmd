---
title: "MCMC"
output:
  html_document:
    toc: true
    number_sections: true
    code_folding: show
---


# Settings

The chapter contains some chunks that conduct document settings.

- This chunk **removes all the variables** in the environment.

```{r SET housekeeping, class.source='fold-hide'}
rm(list = ls(all = TRUE))
```

- This chunk **sets** `knitr` **options**.

```{r SET knit options, class.source='fold-hide'}
knitr::opts_chunk$set(
  block.title = TRUE,
  fig.align = "center",
  results = "hold",
  fig.show = "hold",
  message = FALSE,
  warning = FALSE,
  class.source = 'fold-hide'
)
knitr::opts_hooks$set(label = function(options) {
  options$before = paste0('<div>Chunk: ', options$label, '</div>')
  return(options)
})
```

- This chunk **loads the required packages** and **my functions**.

```{r SET packages, class.source='fold-hide'}
pkgList <- c(
  "tidyverse" #must-have
)
easypackages::libraries(pkgList)
rm(pkgList)
```

- This chunk sets **the seed**.

```{r SET seeds, class.source='fold-hide'}
set.seed(1111)
```

# 準備：マルコフ連鎖

マルコフ連鎖の条件（chap. 3）

$n$個の変数$\{x\}=x_1, x_2, \dots, x_n$を用いて確率$P(\{x\})$を与える

$\{x\}^{(k)}$から$\{x\}^{(k+1)}$が得られる確率「遷移確率」を、$T(\{x\}^{(k)} \rightarrow \{x\}^{(k+1)})$とかく。この時、以下の4つが満たされていること。

(i) マルコフ性

$T(\{x\}^{(k)} \rightarrow \{x\}^{(k+1)})$が、それ以前の履歴（$\{x^{(1)}\}, \{x^{(2)}\}, \dots \{x^{(k-1)}\})$に依存しない…明らか

(ii) 既約性

あらゆる変数の組は、有限回のステップで移りあうことが可能→明らか

(iii) 非周期性

ステップ数 $n_s$ で$\{x\}$から$\{x'\}$に戻ってこれ、その最大公約数が$1$→明らか

(iv) 詳細釣り合い条件

$P(\{x\}) \cdot T(\{x\} \rightarrow \{x'\})=P(\{x'\}) \cdot T(\{x'\} \rightarrow \{x\})$

# メトロポリス法

$$
P(x) = \frac{e^{-S(x)}}{Z} \qquad \text{(4.1)}
$$

e.g. ガウス積分：

$$
P(x) = \frac{e^{\frac{x^2}{2}}}{\sqrt{2\pi}}
$$

メトロポリス法　アルゴリズム

1. $\Delta x$をランダムに選び、$x' = x^{(k)} + \Delta x$を$x^{(k+1)}$の候補とする。

2. 一様乱数 $r \in (0,1)$を発生させる。

3. $e^{S(x^{(k)})-S(x')}>r$、i.e. 候補$x'$の方が現行の$x^{(k)}$より"ある程度"望ましければ、提案を受理して $x^{(k+1)}=x'$とする。さもなくば、提案を棄却して$x^{(k+1)}=x^{(k)}$とする。

なぜこの連鎖が詳細釣り合い条件を満たす？

$$ 
\begin{aligned}
T(x \rightarrow x') &= \frac{1}{2c} \times \min (1, e^{S(x)-S(x')}),\\
T(x' \rightarrow x) &= \frac{1}{2c} \times \min (1, e^{S(x')-S(x)})
\end{aligned}
$$

$S(x)-S(x')>0$のとき、
$$
\begin{aligned}
 P(x) \cdot T(x \rightarrow x') &= \frac{e^{-S(x)}}{Z} \times \frac{1}{2c}\times 1\\
P(x') \cdot T(x' \rightarrow x) &= \frac{e^{-S(x')}}{Z} \times \frac{1}{2c}\times e^{S(x')-S(x)} = \frac{e^{-S(x)}}{Z} \times \frac{1}{2c}\times 1
\end{aligned}
$$
$S(x)-S(x')<0$のときも同様。

## 数値例

$S(x) = e^\frac{x^2}{2}$、すなわち$P(x) = \frac{e^{\frac{x^2}{2}}}{\sqrt{2\pi}}$のケースについて考える。

```{r}
Sfun <- function(x){x^2/2}
```

初期値を$x_0=0$、stepを$\Delta x \sim U(-1,1)$ としたときのアルゴリズムは以下の通り。

```{r}
x_0 <- 0
step <- 1
n_smpl <- 10000

x_smpl <- numeric(n_smpl)
acc_smpl <- logical(n_smpl)

for (i in c(1:n_smpl)){
  # current x
  if(i == 1){
    x_current <- x_0
  } else{
    x_current <- x_smpl[[i-1]]
  }
  # proposed x
  x_prime <- x_current + runif(1, min = -step, max = step)
  
  # probability 
  prob <- min(1, exp(Sfun(x_current)-Sfun(x_prime)))
  
  # accept or reject
  if(prob > runif(1, min = 0, max = 1)){
    x_smpl[[i]] <- x_prime
    acc_smpl[[i]] <- TRUE
  } else{
    x_smpl[[i]] <- x_current
    acc_smpl[[i]] <- FALSE
  }
}
```

```{r}
hist(x_smpl)
ts.plot(x_smpl)
```

```{r}
run_metropolis <- function(
  n_smpl,
  x_0 = 0,
  fun_proposal = function() runif(1, min = -1, max = 1)
){
  # safety checks
  if (!is.numeric(n_smpl) || length(n_smpl) != 1 || n_smpl < 1) {stop("n_smpl must be a positive scalar.")}
  n_smpl <- as.integer(n_smpl)
  if (!exists("Sfun", mode = "function", inherits = TRUE)) {stop("Sfun is not found. ")
  }

  # storage
  x_smpl <- numeric(n_smpl)
  acc <- logical(n_smpl)  # acceptance for each proposed move (length n_smpl)

  # Metropolis random-walk (proposal increment = fun_proposal())
  for (i in 1:n_smpl) {
    # current x
    if(i == 1){
      x_current <- x_0  
    }else{
      x_current <- x_smpl[i-1]
    }
    
    # proposed x
    x_prime   <- x_current + fun_proposal()
    
    # probability
    prob <- min(1, exp(Sfun(x_current) - Sfun(x_prime)))
    
    # accept or reject
    if (prob > runif(1, 0, 1)) {
      x_smpl[i] <- x_prime
      acc[i] <- TRUE
    } else {
      x_smpl[i] <- x_current
      acc[i] <- FALSE
    }
  }

  list(
    x = x_smpl,                      # length n_smpl
    accept = acc,                    # length n_smpl
    accept_rate = mean(acc)
  )
}
```

```{r}
smpl_wide <- run_metropolis(n_smpl, x_0 = x_0, fun_proposal = function() runif(1, min = -10, max = 10))
tbl <- tibble(baseline = x_smpl,
              wide = smpl_wide$x) %>% 
  mutate(baseline_avg = cummean(baseline),
         wide_avg = cummean(wide)
  ) 
```

```{r}
# 累積受容率（cum acceptance ratio）と cummean
df <- tibble(
  t = 1:n_smpl,
  baseline = x_smpl,
  wide     = smpl_wide$x,
  baseline_cummean = cummean(baseline),
  wide_cummean     = cummean(wide),
  baseline_cumacc  = cumsum(acc_smpl) / t,
  wide_cumacc      = cumsum(smpl_wide$accept) / t
)
```


```{r}
# 1) trace plot（同一図に重ねる）
df %>%
  select(t, baseline, wide) %>%
  pivot_longer(-t, names_to = "chain", values_to = "x") %>%
  ggplot(aes(x = t, y = x, color = chain)) +
  geom_line() +
  labs(title = "Trace plot", x = "t", y = "x", color = NULL)

df %>%
  filter(t<=1000) %>% 
  select(t, baseline, wide) %>%
  pivot_longer(-t, names_to = "chain", values_to = "x") %>%
  ggplot(aes(x = t, y = x, color = chain)) +
  geom_line() +
  labs(title = "Trace plot", x = "t", y = "x", color = NULL)

# 2) cummean（同一図に重ねる）
df %>%
  select(t, baseline_cummean, wide_cummean) %>%
  pivot_longer(-t, names_to = "chain", values_to = "cummean") %>%
  mutate(chain = recode(chain,
                        baseline_cummean = "baseline",
                        wide_cummean     = "wide")) %>%
  ggplot(aes(x = t, y = cummean, color = chain)) +
  geom_line() +
  labs(title = "Cumulative mean over t", x = "t", y = "cummean", color = NULL)

# 3) cumulative acceptance ratio（同一図に重ねる）
df %>%
  select(t, baseline_cumacc, wide_cumacc) %>%
  pivot_longer(-t, names_to = "chain", values_to = "cumacc") %>%
  mutate(chain = recode(chain,
                        baseline_cumacc = "baseline",
                        wide_cumacc     = "wide")) %>%
  ggplot(aes(x = t, y = cumacc, color = chain)) +
  geom_line() +
  labs(title = "Cumulative acceptance ratio", x = "t", y = "cum acceptance", color = NULL)

```

Todo; ステップを変えた場合の挙動や自己相関
→Gibbs、MH、HMC
